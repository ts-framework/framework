{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Concept \u00b6 This is a framework for building applications and services of all kinds. It's a logic framework for modular development. It's a framework for building a fantastic developer experience. It's a framework for building frameworks. While other frameworks offer features to achieve a set of focused goals, this framework allows the developer to define the goals, and provides tools to quickly and easily build a tailored platform that supports them. It's also modular. If you design your modules to work independently, you can easily import and reuse them across your applications. You can also import third party modules to quickly add additional functionality. Use cases \u00b6 Frameworks \u00b6 This framework is so powerful that you could recreate the Nest.js framework almost entirely with its built-in features. It features a similar module, service, and controller system as well. I'm not saying you should do that, of course. I'm merely using it as an example of how you can easily create your own customized framework. Copilot \u00b6 This framework is also designed to work alongside other applications and frameworks, especially in the same process. It can be a copilot, if you will. Imagine building a web service that has a pretty complicated backend. You can use this framework for the backend system, since it has many features that make such development easier, and then use NestJS alongside it as a public interface. Front end \u00b6 This framework isn't solely for the server side. One of its main goals is to run alongside front-end frameworks and libraries, such as React and Svelte. Getting started \u00b6 Check out the getting started guide, which offers a quick introduction to the core features of the framework and how you can use them to achieve great things.","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#concept","text":"This is a framework for building applications and services of all kinds. It's a logic framework for modular development. It's a framework for building a fantastic developer experience. It's a framework for building frameworks. While other frameworks offer features to achieve a set of focused goals, this framework allows the developer to define the goals, and provides tools to quickly and easily build a tailored platform that supports them. It's also modular. If you design your modules to work independently, you can easily import and reuse them across your applications. You can also import third party modules to quickly add additional functionality.","title":"Concept"},{"location":"#use-cases","text":"","title":"Use cases"},{"location":"#frameworks","text":"This framework is so powerful that you could recreate the Nest.js framework almost entirely with its built-in features. It features a similar module, service, and controller system as well. I'm not saying you should do that, of course. I'm merely using it as an example of how you can easily create your own customized framework.","title":"Frameworks"},{"location":"#copilot","text":"This framework is also designed to work alongside other applications and frameworks, especially in the same process. It can be a copilot, if you will. Imagine building a web service that has a pretty complicated backend. You can use this framework for the backend system, since it has many features that make such development easier, and then use NestJS alongside it as a public interface.","title":"Copilot"},{"location":"#front-end","text":"This framework isn't solely for the server side. One of its main goals is to run alongside front-end frameworks and libraries, such as React and Svelte.","title":"Front end"},{"location":"#getting-started","text":"Check out the getting started guide, which offers a quick introduction to the core features of the framework and how you can use them to achieve great things.","title":"Getting started"},{"location":"applications/configuring-applications/","text":"Configuring applications \u00b6 Introduction \u00b6 Each application starts with a single root module. However, we use a special class called Application rather than the traditional Module class for this purpose, as the root application instance holds many distinct properties. Like other modules, the constructor() must be overridden and the super() constructor must be subsequently invoked to configure the module and its imports. export class App extends Application { public constructor () { super ({ // Options go here }); } } Options \u00b6 name? : string \u00b6 The optional name of the application. description? : string \u00b6 The optional description of the application. imports? : Importable [] \u00b6 An array of modules to import into the root application module. services? : Constructor < Service > [] \u00b6 An array of services to register into the root application module. controllers? : Constructor < Controller > [] \u00b6 An array of controllers to register into the root application module. envPrefix? : string \u00b6 The prefix to prepend to all environment variables in the application. extensions? : FrameworkExtension [] \u00b6 An array of extensions to register into the application.","title":"Configuring applications"},{"location":"applications/configuring-applications/#configuring-applications","text":"","title":"Configuring applications"},{"location":"applications/configuring-applications/#introduction","text":"Each application starts with a single root module. However, we use a special class called Application rather than the traditional Module class for this purpose, as the root application instance holds many distinct properties. Like other modules, the constructor() must be overridden and the super() constructor must be subsequently invoked to configure the module and its imports. export class App extends Application { public constructor () { super ({ // Options go here }); } }","title":"Introduction"},{"location":"applications/configuring-applications/#options","text":"","title":"Options"},{"location":"applications/configuring-applications/#property:name","text":"The optional name of the application.","title":"name"},{"location":"applications/configuring-applications/#property:description","text":"The optional description of the application.","title":"description"},{"location":"applications/configuring-applications/#property:imports","text":"An array of modules to import into the root application module.","title":"imports"},{"location":"applications/configuring-applications/#property:services","text":"An array of services to register into the root application module.","title":"services"},{"location":"applications/configuring-applications/#property:controllers","text":"An array of controllers to register into the root application module.","title":"controllers"},{"location":"applications/configuring-applications/#property:envPrefix","text":"The prefix to prepend to all environment variables in the application.","title":"envPrefix"},{"location":"applications/configuring-applications/#property:extensions","text":"An array of extensions to register into the application.","title":"extensions"},{"location":"applications/managing-applications/","text":"Managing applications \u00b6 Introduction \u00b6 This guide shows the different ways you can start and stop your application, the associated options, and how to manage things like errors and logging. Creating an instance \u00b6 Before we can start the application, we'll need to acquire an instance of the application. We can't construct it ourselves, or we'll receive an error. Instead, use the ApplicationFactory class to resolve an instance. const app = await ApplicationFactory . create ( App ); The second argument accepts additional options for the application. const app = await ApplicationFactory . create ( App , { loggingLevel : LogLevel.Information , envFilePath : '.env' , environment : {} }); Attaching the instance \u00b6 The recommended method to start an application is with the attach() method. This name comes from the idea that we'll be \"attaching\" the application to the running process, such that when the process is running, our application is running. This method helps automatically configure things like logging, error handling, and graceful shutdowns when interrupt signals are received. await app . attach (); This method also accepts additional options to tailor the attachment. await app . attach ({ interceptTerminationSignals : true , loggingTransports : [ /*console*/ ] }); The attach() method returns a promise that resolves once the application has stopped. You don't need to await this promise if you don't want to. Starting manually \u00b6 If you want full control over how the application is started and managed, then the attach() method might not be sufficient for you. In this case, you'll want to use the start() method manually. This has some important caveats: No transports will be attached to the logger No graceful shutdown hooks will be implemented To see log output, you will need to attach at least one logger transport. const transport = new ConsoleTransport (); transport . attach ( app . logger ); To start the application manually, use the start() method. A promise will be returned that resolves once the application has shut down, or rejects with a critical error. await app . start (); You should then implement logic to call and wait for the stop() method before the process shuts down (such as from a SIGTERM signal), otherwise data loss may occur. await app . stop (); Factory options \u00b6 abortOnError? : boolean = true \u00b6 Sets whether to terminate the process with an erroneous exit code if an unhandled fatal error is encountered within the application. Otherwise the start() or attach() methods will reject with the error. envFilePath? : string = '.env' \u00b6 Sets the name or path of the .env file to use for configuration. This file does not need to exist, as the environment will also be loaded from the process. Set this option to false to disable the file entirely. envPrefix? : string = '' \u00b6 Sets the prefix to use for environment variables in this application. The names of the variables will not change from the application's perspective, but must contain the prefix in the .env file and process environment to be recognized. This is ideal when running multiple applications simultaneously in the same process, in order to isolate their configurations. environment? : Record < string , any > = {} \u00b6 Sets custom environment variables in the application. The variables defined here will override any variables loaded from the working environment or .env file. loggingLevel? : LogLevel | boolean = true \u00b6 Sets the logging level for the application. When not specified, defaults to Info in production and Debug in development. Set to true to use the default logging level and false to disable logging.","title":"Managing applications"},{"location":"applications/managing-applications/#managing-applications","text":"","title":"Managing applications"},{"location":"applications/managing-applications/#introduction","text":"This guide shows the different ways you can start and stop your application, the associated options, and how to manage things like errors and logging.","title":"Introduction"},{"location":"applications/managing-applications/#creating-an-instance","text":"Before we can start the application, we'll need to acquire an instance of the application. We can't construct it ourselves, or we'll receive an error. Instead, use the ApplicationFactory class to resolve an instance. const app = await ApplicationFactory . create ( App ); The second argument accepts additional options for the application. const app = await ApplicationFactory . create ( App , { loggingLevel : LogLevel.Information , envFilePath : '.env' , environment : {} });","title":"Creating an instance"},{"location":"applications/managing-applications/#attaching-the-instance","text":"The recommended method to start an application is with the attach() method. This name comes from the idea that we'll be \"attaching\" the application to the running process, such that when the process is running, our application is running. This method helps automatically configure things like logging, error handling, and graceful shutdowns when interrupt signals are received. await app . attach (); This method also accepts additional options to tailor the attachment. await app . attach ({ interceptTerminationSignals : true , loggingTransports : [ /*console*/ ] }); The attach() method returns a promise that resolves once the application has stopped. You don't need to await this promise if you don't want to.","title":"Attaching the instance"},{"location":"applications/managing-applications/#starting-manually","text":"If you want full control over how the application is started and managed, then the attach() method might not be sufficient for you. In this case, you'll want to use the start() method manually. This has some important caveats: No transports will be attached to the logger No graceful shutdown hooks will be implemented To see log output, you will need to attach at least one logger transport. const transport = new ConsoleTransport (); transport . attach ( app . logger ); To start the application manually, use the start() method. A promise will be returned that resolves once the application has shut down, or rejects with a critical error. await app . start (); You should then implement logic to call and wait for the stop() method before the process shuts down (such as from a SIGTERM signal), otherwise data loss may occur. await app . stop ();","title":"Starting manually"},{"location":"applications/managing-applications/#factory-options","text":"","title":"Factory options"},{"location":"applications/managing-applications/#property:abortOnError","text":"Sets whether to terminate the process with an erroneous exit code if an unhandled fatal error is encountered within the application. Otherwise the start() or attach() methods will reject with the error.","title":"abortOnError"},{"location":"applications/managing-applications/#property:envFilePath","text":"Sets the name or path of the .env file to use for configuration. This file does not need to exist, as the environment will also be loaded from the process. Set this option to false to disable the file entirely.","title":"envFilePath"},{"location":"applications/managing-applications/#property:envPrefix","text":"Sets the prefix to use for environment variables in this application. The names of the variables will not change from the application's perspective, but must contain the prefix in the .env file and process environment to be recognized. This is ideal when running multiple applications simultaneously in the same process, in order to isolate their configurations.","title":"envPrefix"},{"location":"applications/managing-applications/#property:environment","text":"Sets custom environment variables in the application. The variables defined here will override any variables loaded from the working environment or .env file.","title":"environment"},{"location":"applications/managing-applications/#property:loggingLevel","text":"Sets the logging level for the application. When not specified, defaults to Info in production and Debug in development. Set to true to use the default logging level and false to disable logging.","title":"loggingLevel"},{"location":"applications/sending-events/","text":"Sending events \u00b6 Emitting events \u00b6 You can send events into an application for controllers to handle. This allows you to trigger events from outside the application, such as from user input in another part of the application. app . events . emit ( Event ); app . events . emit ( Event , ... args ); Handling events \u00b6 Check out the documentation on service events to get started.","title":"Sending events"},{"location":"applications/sending-events/#sending-events","text":"","title":"Sending events"},{"location":"applications/sending-events/#emitting-events","text":"You can send events into an application for controllers to handle. This allows you to trigger events from outside the application, such as from user input in another part of the application. app . events . emit ( Event ); app . events . emit ( Event , ... args );","title":"Emitting events"},{"location":"applications/sending-events/#handling-events","text":"Check out the documentation on service events to get started.","title":"Handling events"},{"location":"applications/sending-requests/","text":"Sending requests \u00b6 Emitting requests \u00b6 You can send requests into an application for controllers to handle. This allows you to externally request information from an application. const response = await app . requests . emit ( Request ); const response = await app . requests . emit ( Request , ... args ); Handling requests \u00b6 Check out the documentation on service requests to get started.","title":"Sending requests"},{"location":"applications/sending-requests/#sending-requests","text":"","title":"Sending requests"},{"location":"applications/sending-requests/#emitting-requests","text":"You can send requests into an application for controllers to handle. This allows you to externally request information from an application. const response = await app . requests . emit ( Request ); const response = await app . requests . emit ( Request , ... args );","title":"Emitting requests"},{"location":"applications/sending-requests/#handling-requests","text":"Check out the documentation on service requests to get started.","title":"Handling requests"},{"location":"controllers/handling-events/","text":"Handling events \u00b6 Handling with decorations \u00b6 You can turn controller methods into event handlers with the @EventHandler decorator. For this to work, you'll also need to specify the event class as its sole parameter. @EventHandler protected onExampleStarted ( event : ExampleEvent.Started ) { this . logger . info ( 'Started at:' , event . data ); } The framework will attach these methods to the root event manager at startup. It will use runtime reflection to identify the target event type from the parameters. Handling manually \u00b6 You can utilize the application's root event manager to manually listen for events. app . events . on ( ExampleEvent . Started , event => { console . log ( 'Started at:' , event . data ); }); Unlike handlers from decorations, which are detached when the application stops, these event handlers are permanent unless removed with the removeListener() method or using the returned handle's detach() method. Error handling \u00b6 When an error is thrown from an event handler, the error will be caught by the framework and emitted on the controller's error manager as a passive error. This means you don't need to do any special error handling within your callbacks. @EventHandler protected onExampleStarted ( event : ExampleEvent.Started ) { throw new Error ( 'I will be caught and logged' ); }","title":"Handling events"},{"location":"controllers/handling-events/#handling-events","text":"","title":"Handling events"},{"location":"controllers/handling-events/#handling-with-decorations","text":"You can turn controller methods into event handlers with the @EventHandler decorator. For this to work, you'll also need to specify the event class as its sole parameter. @EventHandler protected onExampleStarted ( event : ExampleEvent.Started ) { this . logger . info ( 'Started at:' , event . data ); } The framework will attach these methods to the root event manager at startup. It will use runtime reflection to identify the target event type from the parameters.","title":"Handling with decorations"},{"location":"controllers/handling-events/#handling-manually","text":"You can utilize the application's root event manager to manually listen for events. app . events . on ( ExampleEvent . Started , event => { console . log ( 'Started at:' , event . data ); }); Unlike handlers from decorations, which are detached when the application stops, these event handlers are permanent unless removed with the removeListener() method or using the returned handle's detach() method.","title":"Handling manually"},{"location":"controllers/handling-events/#error-handling","text":"When an error is thrown from an event handler, the error will be caught by the framework and emitted on the controller's error manager as a passive error. This means you don't need to do any special error handling within your callbacks. @EventHandler protected onExampleStarted ( event : ExampleEvent.Started ) { throw new Error ( 'I will be caught and logged' ); }","title":"Error handling"},{"location":"controllers/handling-requests/","text":"Handling requests \u00b6 Handling with decorations \u00b6 You can turn controller methods into request handlers with the @RequestHandler decorator. For this to work, you'll also need to specify the request class as its sole parameter. @RequestHandler protected onAdd ( request : ExampleRequest.Add ) { let sum = 0 ; for ( const number of request . data ) { sum += number ; } request . resolve ( sum ); } The framework will attach these methods to the root request manager at startup. It will use runtime reflection to identify the target request type from the parameters. Handling manually \u00b6 You can utilize the application's root request manager to manually register handlers. app . requests . register ( ExampleRequest . Add , request => { request . resolve ( 6 ); }); At this time, these handlers are permanent once attached. Error handling \u00b6 When an error is thrown from a request handler, the error will be propagated to the caller, and it will be up to the caller to handle it. Errors can also be thrown for the caller if no handlers are available to handle the request.","title":"Handling requests"},{"location":"controllers/handling-requests/#handling-requests","text":"","title":"Handling requests"},{"location":"controllers/handling-requests/#handling-with-decorations","text":"You can turn controller methods into request handlers with the @RequestHandler decorator. For this to work, you'll also need to specify the request class as its sole parameter. @RequestHandler protected onAdd ( request : ExampleRequest.Add ) { let sum = 0 ; for ( const number of request . data ) { sum += number ; } request . resolve ( sum ); } The framework will attach these methods to the root request manager at startup. It will use runtime reflection to identify the target request type from the parameters.","title":"Handling with decorations"},{"location":"controllers/handling-requests/#handling-manually","text":"You can utilize the application's root request manager to manually register handlers. app . requests . register ( ExampleRequest . Add , request => { request . resolve ( 6 ); }); At this time, these handlers are permanent once attached.","title":"Handling manually"},{"location":"controllers/handling-requests/#error-handling","text":"When an error is thrown from a request handler, the error will be propagated to the caller, and it will be up to the caller to handle it. Errors can also be thrown for the caller if no handlers are available to handle the request.","title":"Error handling"},{"location":"controllers/implementing-controllers/","text":"Implementing controllers \u00b6 Controllers are special classes that are intended solely for handling events and requests. For complex applications, you will primarily use attributes in your controllers as well, as they can be considered special types of event handlers. Implementation \u00b6 @Injectable () export class ExampleController extends Controller < ExampleModule > { } Dependencies \u00b6 If you're developing with separation of concerns, you'll likely want to import one or more services into your controller by specifying them as constructor parameters. public constructor ( protected readonly service : ExampleService ) { super (); } Make sure that you've applied the @Injectable () decorator to the class, otherwise the framework won't be able to see the types of your parameters. Using controllers \u00b6 That's all there is to controllers! They are useless on their own, so the next few sections will show the various ways you can utilize controllers. Using attributes Handling events Handling requests","title":"Implementing controllers"},{"location":"controllers/implementing-controllers/#implementing-controllers","text":"Controllers are special classes that are intended solely for handling events and requests. For complex applications, you will primarily use attributes in your controllers as well, as they can be considered special types of event handlers.","title":"Implementing controllers"},{"location":"controllers/implementing-controllers/#implementation","text":"@Injectable () export class ExampleController extends Controller < ExampleModule > { }","title":"Implementation"},{"location":"controllers/implementing-controllers/#dependencies","text":"If you're developing with separation of concerns, you'll likely want to import one or more services into your controller by specifying them as constructor parameters. public constructor ( protected readonly service : ExampleService ) { super (); } Make sure that you've applied the @Injectable () decorator to the class, otherwise the framework won't be able to see the types of your parameters.","title":"Dependencies"},{"location":"controllers/implementing-controllers/#using-controllers","text":"That's all there is to controllers! They are useless on their own, so the next few sections will show the various ways you can utilize controllers. Using attributes Handling events Handling requests","title":"Using controllers"},{"location":"controllers/using-attributes/","text":"Using attributes \u00b6 Creating attributes \u00b6 Make sure to read the services guide on adding attributes to the application. It also talks about what attributes are and how they're useful. Using attributes \u00b6 Attributes are decorators and can be applied to classes, methods, properties, and parameters. Each attribute can define which of those four target types it's applicable to, so you won't be able to use every attribute for every type. @AttributeName () export class ExampleController extends Controller < ExampleModule > { @AttributeName () public async method () { } } Attributes do not extend functionality on their own. In order for them to do anything, they'll need an associated service to power them. If you're using third party attributes, make sure you've also imported its module into your application.","title":"Using attributes"},{"location":"controllers/using-attributes/#using-attributes","text":"","title":"Using attributes"},{"location":"controllers/using-attributes/#creating-attributes","text":"Make sure to read the services guide on adding attributes to the application. It also talks about what attributes are and how they're useful.","title":"Creating attributes"},{"location":"controllers/using-attributes/#using-attributes_1","text":"Attributes are decorators and can be applied to classes, methods, properties, and parameters. Each attribute can define which of those four target types it's applicable to, so you won't be able to use every attribute for every type. @AttributeName () export class ExampleController extends Controller < ExampleModule > { @AttributeName () public async method () { } } Attributes do not extend functionality on their own. In order for them to do anything, they'll need an associated service to power them. If you're using third party attributes, make sure you've also imported its module into your application.","title":"Using attributes"},{"location":"extensions/developing-extensions/","text":"Developing extensions \u00b6 Extensions allow you to add additional methods and properties to the framework's core classes, and to run code when they are constructed, started, and stopped. The following guide will demonstrate how to successfully add a property and method to services, controllers, and modules. Install the framework \u00b6 You will need to use classes and types from the framework as part of your extension. Add the framework as both a dev and peer dependency in your package.json : \"devDependencies\" : { \"@ts-framework/core\" : \"^1.0.0\" }, \"peerDependencies\" : { \"@ts-framework/core\" : \"^1.0.0\" } Then run npm install to download the new packages. Create the extension \u00b6 First create a class that extends FrameworkExtension . Instances of this class can be imported into applications to register the extension. import { FrameworkExtension } from '@ts-framework/core' ; export class ExampleExtension extends FrameworkExtension { } Registration handler \u00b6 Override the onRegister() method. This method will be invoked as soon as the extension is registered into an application, and will receive a CompositionBuilder instance that can be used to initiate augmentation. protected override onRegister ( builder : ComposerBuilder ) { } Instance augmentation \u00b6 From within the onRegister() method, you can use the builder instance to listen for the construction of specific types of instances in the framework. protected override onRegister ( builder : ComposerBuilder ) { builder . attach ( Application , composer => {}); builder . attach ( Module , composer => {}); builder . attach ( Service , composer => {}); builder . attach ( Controller , composer => {}); } The callbacks in these attachments will be invoked for each constructed instance which inherits those types along with a Composer object that can be used to augment them. Warning You can't pass any type in the attach() method and expect it to work. It only works against classes which invoke the application.extensions.augment() method at construction time. Here are the core classes that support augmentation in this manner: Application Module Service Controller StateManager ScheduleManager PromiseManager Adding properties \u00b6 To add a property to an instance, use the createProperty() method on the composer. Provide the initial value of the property. composer . createProperty ( 'example' , 'This was set from an extension' ); Adding methods \u00b6 To add a method to an instance, use the createMethod() method on the composer. Provide a callback that will be used as the method's implementation. composer . createMethod ( 'example' , () => { return 'This was returned by an extension' ; }); Adding getters \u00b6 To add a getter to an instance, use the createGetter() method on the composer. Pass a callback that will be used as the getter's implementation. composer . createGetter ( 'example' , () => { return 'This was returned by an extension' ; }); Adding setters \u00b6 To add a setter to an instance, use the createSetter() method on the composer. Pass a callback that will be used as the setter's implementation. composer . createSetter ( 'example' , ( value : any ) => { // Do something with the value }); Descriptors \u00b6 Properties, getters, and setters are added to instances via property descriptors. For advanced use cases, composers allow you to customize the options in those descriptors. The available options and their default values are listed below. composer . configurable = false ; composer . enumerable = true ; composer . writable = true ; Please note that the above options will apply to all descriptors created by the composer, regardless of the order in which they were registered. Type augmentation \u00b6 The composers demonstrated above will add new properties, methods, and other descriptors to instances of core framework classes. However, the compiler will complain that these values do not exist, because they are still not typed. The following code demonstrates how to augment the official types for each of the core classes that support composer augmentation. declare module '@ts-framework/core/dist/application/Application' { interface Application { example : string ; } } declare module '@ts-framework/core/dist/modules/Module' { interface Module { example : string ; } } declare module '@ts-framework/core/dist/controllers/Controller' { interface Controller { example : string ; } } declare module '@ts-framework/core/dist/services/Service' { interface Service { example : string ; } } declare module '@ts-framework/core/dist/services/state/StateManager' { interface StateManager { example : string ; } } declare module '@ts-framework/core/dist/services/scheduler/ScheduleManager' { interface ScheduleManager { example : string ; } } declare module '@ts-framework/core/dist/services/promises/PromiseManager' { interface PromiseManager { example : string ; } } Techniques \u00b6 Logging \u00b6 Extensions have an internal logger as well. When the extension is registered into an application, this logger is automatically attached to the application's root logger. This happens before the extension is invoked in any way. this . logger . info ( 'Hello application!' ); Events \u00b6 For some types, composers also emit events for their underlying instances. composer . on ( 'beforeStart' , () => { this . logger . info ( composer . reflection . name , 'is starting' ); }); These are the events you can subscribe to, although usage will vary by type: afterResolution \u2013 After the framework has resolved and registered the instance beforeStart \u2013 Immediately before the target is started beforeStop \u2013 Immediately before the target is stopped afterStart \u2013 Immediately after the target was started afterStop \u2013 Immediately after the target was stopped Error handling \u00b6 Extensions have an error property which exposes a dedicated error manager. When the extension is attached to an application, this error manager is automatically propagated up into the application's root error manager. To pipe a passive (non-fatal) error into the application at runtime, use the emitPassiveError() method. The application will continue operating. this . errors . emitPassiveError ( new Error ( 'Something went wrong' )); To pipe a critical (fatal) error into the application at runtime, use the emitCriticalError() method. The application will shut down due to the error. this . errors . emitCriticalError ( new Error ( 'Something went wrong' ));","title":"Developing extensions"},{"location":"extensions/developing-extensions/#developing-extensions","text":"Extensions allow you to add additional methods and properties to the framework's core classes, and to run code when they are constructed, started, and stopped. The following guide will demonstrate how to successfully add a property and method to services, controllers, and modules.","title":"Developing extensions"},{"location":"extensions/developing-extensions/#install-the-framework","text":"You will need to use classes and types from the framework as part of your extension. Add the framework as both a dev and peer dependency in your package.json : \"devDependencies\" : { \"@ts-framework/core\" : \"^1.0.0\" }, \"peerDependencies\" : { \"@ts-framework/core\" : \"^1.0.0\" } Then run npm install to download the new packages.","title":"Install the framework"},{"location":"extensions/developing-extensions/#create-the-extension","text":"First create a class that extends FrameworkExtension . Instances of this class can be imported into applications to register the extension. import { FrameworkExtension } from '@ts-framework/core' ; export class ExampleExtension extends FrameworkExtension { }","title":"Create the extension"},{"location":"extensions/developing-extensions/#registration-handler","text":"Override the onRegister() method. This method will be invoked as soon as the extension is registered into an application, and will receive a CompositionBuilder instance that can be used to initiate augmentation. protected override onRegister ( builder : ComposerBuilder ) { }","title":"Registration handler"},{"location":"extensions/developing-extensions/#instance-augmentation","text":"From within the onRegister() method, you can use the builder instance to listen for the construction of specific types of instances in the framework. protected override onRegister ( builder : ComposerBuilder ) { builder . attach ( Application , composer => {}); builder . attach ( Module , composer => {}); builder . attach ( Service , composer => {}); builder . attach ( Controller , composer => {}); } The callbacks in these attachments will be invoked for each constructed instance which inherits those types along with a Composer object that can be used to augment them. Warning You can't pass any type in the attach() method and expect it to work. It only works against classes which invoke the application.extensions.augment() method at construction time. Here are the core classes that support augmentation in this manner: Application Module Service Controller StateManager ScheduleManager PromiseManager","title":"Instance augmentation"},{"location":"extensions/developing-extensions/#adding-properties","text":"To add a property to an instance, use the createProperty() method on the composer. Provide the initial value of the property. composer . createProperty ( 'example' , 'This was set from an extension' );","title":"Adding properties"},{"location":"extensions/developing-extensions/#adding-methods","text":"To add a method to an instance, use the createMethod() method on the composer. Provide a callback that will be used as the method's implementation. composer . createMethod ( 'example' , () => { return 'This was returned by an extension' ; });","title":"Adding methods"},{"location":"extensions/developing-extensions/#adding-getters","text":"To add a getter to an instance, use the createGetter() method on the composer. Pass a callback that will be used as the getter's implementation. composer . createGetter ( 'example' , () => { return 'This was returned by an extension' ; });","title":"Adding getters"},{"location":"extensions/developing-extensions/#adding-setters","text":"To add a setter to an instance, use the createSetter() method on the composer. Pass a callback that will be used as the setter's implementation. composer . createSetter ( 'example' , ( value : any ) => { // Do something with the value });","title":"Adding setters"},{"location":"extensions/developing-extensions/#descriptors","text":"Properties, getters, and setters are added to instances via property descriptors. For advanced use cases, composers allow you to customize the options in those descriptors. The available options and their default values are listed below. composer . configurable = false ; composer . enumerable = true ; composer . writable = true ; Please note that the above options will apply to all descriptors created by the composer, regardless of the order in which they were registered.","title":"Descriptors"},{"location":"extensions/developing-extensions/#type-augmentation","text":"The composers demonstrated above will add new properties, methods, and other descriptors to instances of core framework classes. However, the compiler will complain that these values do not exist, because they are still not typed. The following code demonstrates how to augment the official types for each of the core classes that support composer augmentation. declare module '@ts-framework/core/dist/application/Application' { interface Application { example : string ; } } declare module '@ts-framework/core/dist/modules/Module' { interface Module { example : string ; } } declare module '@ts-framework/core/dist/controllers/Controller' { interface Controller { example : string ; } } declare module '@ts-framework/core/dist/services/Service' { interface Service { example : string ; } } declare module '@ts-framework/core/dist/services/state/StateManager' { interface StateManager { example : string ; } } declare module '@ts-framework/core/dist/services/scheduler/ScheduleManager' { interface ScheduleManager { example : string ; } } declare module '@ts-framework/core/dist/services/promises/PromiseManager' { interface PromiseManager { example : string ; } }","title":"Type augmentation"},{"location":"extensions/developing-extensions/#techniques","text":"","title":"Techniques"},{"location":"extensions/developing-extensions/#logging","text":"Extensions have an internal logger as well. When the extension is registered into an application, this logger is automatically attached to the application's root logger. This happens before the extension is invoked in any way. this . logger . info ( 'Hello application!' );","title":"Logging"},{"location":"extensions/developing-extensions/#events","text":"For some types, composers also emit events for their underlying instances. composer . on ( 'beforeStart' , () => { this . logger . info ( composer . reflection . name , 'is starting' ); }); These are the events you can subscribe to, although usage will vary by type: afterResolution \u2013 After the framework has resolved and registered the instance beforeStart \u2013 Immediately before the target is started beforeStop \u2013 Immediately before the target is stopped afterStart \u2013 Immediately after the target was started afterStop \u2013 Immediately after the target was stopped","title":"Events"},{"location":"extensions/developing-extensions/#error-handling","text":"Extensions have an error property which exposes a dedicated error manager. When the extension is attached to an application, this error manager is automatically propagated up into the application's root error manager. To pipe a passive (non-fatal) error into the application at runtime, use the emitPassiveError() method. The application will continue operating. this . errors . emitPassiveError ( new Error ( 'Something went wrong' )); To pipe a critical (fatal) error into the application at runtime, use the emitCriticalError() method. The application will shut down due to the error. this . errors . emitCriticalError ( new Error ( 'Something went wrong' ));","title":"Error handling"},{"location":"extensions/extension-modules/","text":"Extension modules \u00b6 Introduction \u00b6 In some cases you may wish to create a module that automatically imports an extension into the parent application. The special ExtensionModule decorator allows you to build a normal module which brings its own extension(s) to the application if they are not already added. Usage \u00b6 @ExtensionModule ( ExampleExtension ) export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [], controllers : [], }); } } Now the application will ensure that the ExampleExtension is registered into the application before the module import cycle even begins. Warning This feature only works for top level modules (those imported directly from the root application module). It does not look for extensions in nested modules to ensure the extension lifecycle is consistent regardless of how they are imported. If that won't work for you, then import the extension directly into the application.","title":"Extension modules"},{"location":"extensions/extension-modules/#extension-modules","text":"","title":"Extension modules"},{"location":"extensions/extension-modules/#introduction","text":"In some cases you may wish to create a module that automatically imports an extension into the parent application. The special ExtensionModule decorator allows you to build a normal module which brings its own extension(s) to the application if they are not already added.","title":"Introduction"},{"location":"extensions/extension-modules/#usage","text":"@ExtensionModule ( ExampleExtension ) export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [], controllers : [], }); } } Now the application will ensure that the ExampleExtension is registered into the application before the module import cycle even begins. Warning This feature only works for top level modules (those imported directly from the root application module). It does not look for extensions in nested modules to ensure the extension lifecycle is consistent regardless of how they are imported. If that won't work for you, then import the extension directly into the application.","title":"Usage"},{"location":"extensions/using-extensions/","text":"Using extensions \u00b6 Introduction \u00b6 You can add a lot of functionality to your applications with attributes, but one of the primary goals for this framework is to keep all the essential near developers at all times. We achieve this by exposing them as properties on the Service , Controller , Module , and Application classes, so that your most important and frequently-used tools are one this away at all times. But what if there's something missing? Well, it's very easy to add additional properties and methods to these core classes \u2013 and to run code when they are instantiated, started, and stopped \u2013 using the built-in extensions system. Some of the official framework packages use extensions to implement their features, including: @ts-framework/storage @ts-framework/scheduling @ts-framework/queues Installing extensions \u00b6 First, install the extension into your project as a dependency. npm install @ts-framework/storage Then import the extension into the extensions option for your application. import { StorageExtension } from '@ts-framework/storage' ; export class App extends Application { public constructor () { super ({ extensions : [ new StorageExtension () ] }) } } These extension constructors might accept options to customize their behavior. You'll also need to make sure that the extensions you import are compatible with the framework's current major version, otherwise you might receive an error on the new StorageExtension () line. With the extension imported into the application as shown above, it will take effect immediately, and you can begin using any properties and methods it added to the core classes. Tip If your editor or compiler is telling you that any newly-added properties and methods don't exist, you may need to give it a restart before the new types will be recognized.","title":"Using extensions"},{"location":"extensions/using-extensions/#using-extensions","text":"","title":"Using extensions"},{"location":"extensions/using-extensions/#introduction","text":"You can add a lot of functionality to your applications with attributes, but one of the primary goals for this framework is to keep all the essential near developers at all times. We achieve this by exposing them as properties on the Service , Controller , Module , and Application classes, so that your most important and frequently-used tools are one this away at all times. But what if there's something missing? Well, it's very easy to add additional properties and methods to these core classes \u2013 and to run code when they are instantiated, started, and stopped \u2013 using the built-in extensions system. Some of the official framework packages use extensions to implement their features, including: @ts-framework/storage @ts-framework/scheduling @ts-framework/queues","title":"Introduction"},{"location":"extensions/using-extensions/#installing-extensions","text":"First, install the extension into your project as a dependency. npm install @ts-framework/storage Then import the extension into the extensions option for your application. import { StorageExtension } from '@ts-framework/storage' ; export class App extends Application { public constructor () { super ({ extensions : [ new StorageExtension () ] }) } } These extension constructors might accept options to customize their behavior. You'll also need to make sure that the extensions you import are compatible with the framework's current major version, otherwise you might receive an error on the new StorageExtension () line. With the extension imported into the application as shown above, it will take effect immediately, and you can begin using any properties and methods it added to the core classes. Tip If your editor or compiler is telling you that any newly-added properties and methods don't exist, you may need to give it a restart before the new types will be recognized.","title":"Installing extensions"},{"location":"getting-started/creating-applications/","text":"Creating applications \u00b6 Create the application class \u00b6 Create a class called App to act as the root module of the application. This class will extend the abstract Application class exposed by the framework. You must then invoke the super () constructor to set the application's options. src/App.ts import { Application } from '@ts-framework/core' ; export class App extends Application { public constructor () { super ({ imports : [], }); } } Starting the application \u00b6 With the root application module defined, let's edit the main entry file of your project such as main.ts and attach the application to the process. src/main.ts import { App } from './App' ; app . attach (); The attach () method is a shortcut that configures the logging level, attaches logging transports, intercepts terminational signals (for a graceful exit), and then starts the application.","title":"Creating applications"},{"location":"getting-started/creating-applications/#creating-applications","text":"","title":"Creating applications"},{"location":"getting-started/creating-applications/#create-the-application-class","text":"Create a class called App to act as the root module of the application. This class will extend the abstract Application class exposed by the framework. You must then invoke the super () constructor to set the application's options. src/App.ts import { Application } from '@ts-framework/core' ; export class App extends Application { public constructor () { super ({ imports : [], }); } }","title":"Create the application class"},{"location":"getting-started/creating-applications/#starting-the-application","text":"With the root application module defined, let's edit the main entry file of your project such as main.ts and attach the application to the process. src/main.ts import { App } from './App' ; app . attach (); The attach () method is a shortcut that configures the logging level, attaches logging transports, intercepts terminational signals (for a graceful exit), and then starts the application.","title":"Starting the application"},{"location":"getting-started/creating-attributes/","text":"Creating attributes \u00b6 Introduction \u00b6 Here's where the fun really begins! Other frameworks solve particular problems. For example, Nest.js makes it simple to interface with a web server using decorators within controllers. On the other hand, this framework solves no particular problems \u2013 not a single one! Instead, you can build your own solutions to whatever problems you face using service attributes . Need @Get() and @Post() decorators? They can be written in minutes! The framework builds upon the attributes decoration concept introduced in my reflection library . If you're not familiar, attributes are simple classes that are easily converted into decorators, and a class instance is preserved for each decoration. Services have first-class integration with attributes. The framework tracks attribute instances and makes it extremely easy to query and interface with them. This guide will demonstrate how to create the @Get() , @Req() , and @Res() decorators and bind them to a service that spins up an express server. For the record, you don't actually need to do this yourself \u2013 check out the express integration . Create the decorators \u00b6 First and foremost, we'll create the @Get() decorator using an attribute. src/example/attributes/Get.ts import { Attribute , AttributeMethodEvent , Component } from '@ts-framework/core' ; export const Get = Attribute . create ( class GetAttribute extends Attribute { public constructor ( public readonly path : string ) { super (); } public override onMethod ( event : AttributeMethodEvent < Component , any > ) {} }); Check the upstream documentation on attributes to learn how to easily write your own attributes. In short, by overriding onMethod() in our implementation, we've enabled the attribute to be used on methods, with the constructor argument path as its sole parameter. Create the helper tokens \u00b6 We'll also need the @Req() and @Res() decorators to make it easier to inject the express Request and Response types which don't have an equivalent class readily available for injection. src/example/decorators/Req.ts import { Token } from '@ts-framework/core' ; export const Req = () => Token ( 'express:request' ); src/example/decorators/Res.ts import { Token } from '@ts-framework/core' ; export const Res = () => Token ( 'express:response' ); To make this work, we'll need to tell the dependency container what values to inject for these tokens when we invoke the methods that use them. Fortunately, this is very easy to do with the framework's attribute system, as you're about to see. Create the service \u00b6 Create a new HttpService and register it in a module of your choosing. Then read over and implement the code show below. src/example/HttpService.ts import { PromiseCompletionSource , Service } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; import { Get } from './attributes/Get' ; import { Server } from 'http' ; import express from 'express' ; export class HttpService extends Service < ExampleModule > { private app = express (); private server? : Server ; protected override register () { // (1) for ( const registration of this . application . attributes . getMethods ( Get )) { this . app . get ( registration . first (). path , async ( req , res ) => { const dispatcher = registration . dispatchers [ 0 ]. clone (); // (2) dispatcher . setTokenParameter ( 'express:request' , req ); // (3) dispatcher . setTokenParameter ( 'express:response' , res ); const response = await dispatcher . invoke (); // (4) if ( response ) { res . send ( response ); // (5) } }); } } protected override async start () { const source = new PromiseCompletionSource < void > (); this . server = this . app . listen ( 3000 , () => source . resolve ()); // (6) return source . promise ; } protected override async stop () { if ( this . server ) { const source = new PromiseCompletionSource < void > (); this . server . close (() => source . resolve ()); return source . promise ; } } } This is a special method that runs immediately before the service is started for the first time. It won't run again, making it great for slow, one-time operations like applying attributes. The registration object for method-based attributes exposes a dispatcher that can be used to easily invoke the method with dependency injection. We're making a clone to avoid contaminating the original dispatcher object. It's also an array in case there are multiple instances of the same controller available. Here, we're overriding the injection behavior for these specific tokens, which we set with the decorators in the previous section. The container will inject these values for the parameters instead. This will invoke the controller method that registered the route and then forward its return value. We'll await this value just in case it's a promise. If the controller method returned anything, let's add it to the response and send it off. This makes it easier for controllers to send their responses. Here we do some magic to promisify the listen step. We'll repeat similar magic when closing the server. Using the attribute \u00b6 With the attribute and service configured, we can now easily configure and handle routes from any controller in the entire application! src/example/ExampleController.ts export class ExampleController extends Controller < ExampleModule > { @Get ( '/' ) public async index ( @Req () request : Request , @Res () response : Response ) { return 'Hello world!' ; } } Give localhost:3000 a view and you should see the familiar greeting. Conclusion \u00b6 I hope this demonstrates the versatility of this framework. In this manner, it's a framework to create other frameworks, and most of the magic relies on the attribute system. It should be possible to recreate Nest.js in its entirety, or to create an entirely different framework.","title":"Creating attributes"},{"location":"getting-started/creating-attributes/#creating-attributes","text":"","title":"Creating attributes"},{"location":"getting-started/creating-attributes/#introduction","text":"Here's where the fun really begins! Other frameworks solve particular problems. For example, Nest.js makes it simple to interface with a web server using decorators within controllers. On the other hand, this framework solves no particular problems \u2013 not a single one! Instead, you can build your own solutions to whatever problems you face using service attributes . Need @Get() and @Post() decorators? They can be written in minutes! The framework builds upon the attributes decoration concept introduced in my reflection library . If you're not familiar, attributes are simple classes that are easily converted into decorators, and a class instance is preserved for each decoration. Services have first-class integration with attributes. The framework tracks attribute instances and makes it extremely easy to query and interface with them. This guide will demonstrate how to create the @Get() , @Req() , and @Res() decorators and bind them to a service that spins up an express server. For the record, you don't actually need to do this yourself \u2013 check out the express integration .","title":"Introduction"},{"location":"getting-started/creating-attributes/#create-the-decorators","text":"First and foremost, we'll create the @Get() decorator using an attribute. src/example/attributes/Get.ts import { Attribute , AttributeMethodEvent , Component } from '@ts-framework/core' ; export const Get = Attribute . create ( class GetAttribute extends Attribute { public constructor ( public readonly path : string ) { super (); } public override onMethod ( event : AttributeMethodEvent < Component , any > ) {} }); Check the upstream documentation on attributes to learn how to easily write your own attributes. In short, by overriding onMethod() in our implementation, we've enabled the attribute to be used on methods, with the constructor argument path as its sole parameter.","title":"Create the decorators"},{"location":"getting-started/creating-attributes/#create-the-helper-tokens","text":"We'll also need the @Req() and @Res() decorators to make it easier to inject the express Request and Response types which don't have an equivalent class readily available for injection. src/example/decorators/Req.ts import { Token } from '@ts-framework/core' ; export const Req = () => Token ( 'express:request' ); src/example/decorators/Res.ts import { Token } from '@ts-framework/core' ; export const Res = () => Token ( 'express:response' ); To make this work, we'll need to tell the dependency container what values to inject for these tokens when we invoke the methods that use them. Fortunately, this is very easy to do with the framework's attribute system, as you're about to see.","title":"Create the helper tokens"},{"location":"getting-started/creating-attributes/#create-the-service","text":"Create a new HttpService and register it in a module of your choosing. Then read over and implement the code show below. src/example/HttpService.ts import { PromiseCompletionSource , Service } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; import { Get } from './attributes/Get' ; import { Server } from 'http' ; import express from 'express' ; export class HttpService extends Service < ExampleModule > { private app = express (); private server? : Server ; protected override register () { // (1) for ( const registration of this . application . attributes . getMethods ( Get )) { this . app . get ( registration . first (). path , async ( req , res ) => { const dispatcher = registration . dispatchers [ 0 ]. clone (); // (2) dispatcher . setTokenParameter ( 'express:request' , req ); // (3) dispatcher . setTokenParameter ( 'express:response' , res ); const response = await dispatcher . invoke (); // (4) if ( response ) { res . send ( response ); // (5) } }); } } protected override async start () { const source = new PromiseCompletionSource < void > (); this . server = this . app . listen ( 3000 , () => source . resolve ()); // (6) return source . promise ; } protected override async stop () { if ( this . server ) { const source = new PromiseCompletionSource < void > (); this . server . close (() => source . resolve ()); return source . promise ; } } } This is a special method that runs immediately before the service is started for the first time. It won't run again, making it great for slow, one-time operations like applying attributes. The registration object for method-based attributes exposes a dispatcher that can be used to easily invoke the method with dependency injection. We're making a clone to avoid contaminating the original dispatcher object. It's also an array in case there are multiple instances of the same controller available. Here, we're overriding the injection behavior for these specific tokens, which we set with the decorators in the previous section. The container will inject these values for the parameters instead. This will invoke the controller method that registered the route and then forward its return value. We'll await this value just in case it's a promise. If the controller method returned anything, let's add it to the response and send it off. This makes it easier for controllers to send their responses. Here we do some magic to promisify the listen step. We'll repeat similar magic when closing the server.","title":"Create the service"},{"location":"getting-started/creating-attributes/#using-the-attribute","text":"With the attribute and service configured, we can now easily configure and handle routes from any controller in the entire application! src/example/ExampleController.ts export class ExampleController extends Controller < ExampleModule > { @Get ( '/' ) public async index ( @Req () request : Request , @Res () response : Response ) { return 'Hello world!' ; } } Give localhost:3000 a view and you should see the familiar greeting.","title":"Using the attribute"},{"location":"getting-started/creating-attributes/#conclusion","text":"I hope this demonstrates the versatility of this framework. In this manner, it's a framework to create other frameworks, and most of the magic relies on the attribute system. It should be possible to recreate Nest.js in its entirety, or to create an entirely different framework.","title":"Conclusion"},{"location":"getting-started/creating-controllers/","text":"Creating controllers \u00b6 Controllers are classes that handle events dispatched by the application's services. That might sound simple, but events in this framework come in many forms and controllers can easily become the stars of your application. Create the controller class \u00b6 Create a class called ExampleController alongside its parent module that looks like the following: src/example/ExampleController.ts import { Injectable , Controller } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { } For now, there's nothing to put in the controller, so we'll keep it empty. The next guide will modify the service to emit events, and show how to handle those events in the controller. Import the controller \u00b6 Go back to the ExampleModule.ts file and add the new class to the controllers array. src/example/ExampleModule.ts import { Module } from '@ts-framework/core' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; import { ExampleController } from './ExampleController' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [ ExampleController ], }); } }","title":"Creating controllers"},{"location":"getting-started/creating-controllers/#creating-controllers","text":"Controllers are classes that handle events dispatched by the application's services. That might sound simple, but events in this framework come in many forms and controllers can easily become the stars of your application.","title":"Creating controllers"},{"location":"getting-started/creating-controllers/#create-the-controller-class","text":"Create a class called ExampleController alongside its parent module that looks like the following: src/example/ExampleController.ts import { Injectable , Controller } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { } For now, there's nothing to put in the controller, so we'll keep it empty. The next guide will modify the service to emit events, and show how to handle those events in the controller.","title":"Create the controller class"},{"location":"getting-started/creating-controllers/#import-the-controller","text":"Go back to the ExampleModule.ts file and add the new class to the controllers array. src/example/ExampleModule.ts import { Module } from '@ts-framework/core' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; import { ExampleController } from './ExampleController' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [ ExampleController ], }); } }","title":"Import the controller"},{"location":"getting-started/creating-events/","text":"Creating events \u00b6 This framework introduces a simple concept called service events that makes it extremely easy to listen to and handle events from anywhere in your application. As the name implies, these events typically originate from services as part of their background work. Traditionally, events in the JavaScript ecosystem have used strings as their identifiers. This leads to some difficulty when dealing with collisions and type hinting. Here, we use classes instead of strings for our events, and this solves both of those problems. Create the event namespace \u00b6 The current convention is export a service's events within a namespace. Let's create a simple ExampleEvent namespace within our module's directory. You can skip this step if you'd like. src/example/ExampleEvent.ts export namespace ExampleEvent { } Create the event class \u00b6 Now export a class inside the namespace, making sure to extend the base Event<T> class. If the T decorator is not supplied, the event will not accept any data, otherwise you may specify the type of data it accepts. Let's create an event called ExampleEvent.IntervalInvoked that accepts an object as its data type. Inside this object, we'll pass a random number, because why not? src/example/ExampleEvent.ts import { Event } from '@ts-framework/core' ; export namespace ExampleEvent { /** * Emitted when the example service's interval is invoked. The service * will generate and pass a random number with each invocation. */ export class Interval extends Event < { randomNumber : number } > {} } Handle the event \u00b6 Let's go back to the ExampleController class and add a method to handle this event. You can give this method any name, as long as it has the @EventHandler decorator and accepts the event as its sole argument. src/example/ExampleController.ts import { Injectable , Controller , EventHandler } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { @EventHandler public onInterval ( event : ExampleEvent.Interval ) { this . logger . info ( 'Got an invocation with random number:' , event . data . randomNumber ); } } Emit the event \u00b6 Now let's go back to the ExampleService class and change the interval's callback to generate a random number and emit the event. src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; import { ExampleEvent } from './ExampleEvent' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . emit ( ExampleEvent . Interval , { randomNumber : Math.floor ( Math . random () * 1000 ) }); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } After saving and running with the new changes, you will immediately see the controller logging a new random number with each passing second. Learn more \u00b6 Events are emitted globally and can be handled by controllers across the application, including in unrelated modules. This is possible due to the fact that each event class is its own unique signature, thus preventing collisions. You can also emit and listen for events manually using the application's event manager, however using the emit() method inside services is preferred. // Emitting events app . events . emit ( ExampleEvent . Interval , { randomNumber : 0 }); // Listening to events app . events . on ( ExampleEvent . Interval , event => { console . log ( event . data . randomNumber ); }); For more advanced usage details, check out the complete service events guide .","title":"Creating events"},{"location":"getting-started/creating-events/#creating-events","text":"This framework introduces a simple concept called service events that makes it extremely easy to listen to and handle events from anywhere in your application. As the name implies, these events typically originate from services as part of their background work. Traditionally, events in the JavaScript ecosystem have used strings as their identifiers. This leads to some difficulty when dealing with collisions and type hinting. Here, we use classes instead of strings for our events, and this solves both of those problems.","title":"Creating events"},{"location":"getting-started/creating-events/#create-the-event-namespace","text":"The current convention is export a service's events within a namespace. Let's create a simple ExampleEvent namespace within our module's directory. You can skip this step if you'd like. src/example/ExampleEvent.ts export namespace ExampleEvent { }","title":"Create the event namespace"},{"location":"getting-started/creating-events/#create-the-event-class","text":"Now export a class inside the namespace, making sure to extend the base Event<T> class. If the T decorator is not supplied, the event will not accept any data, otherwise you may specify the type of data it accepts. Let's create an event called ExampleEvent.IntervalInvoked that accepts an object as its data type. Inside this object, we'll pass a random number, because why not? src/example/ExampleEvent.ts import { Event } from '@ts-framework/core' ; export namespace ExampleEvent { /** * Emitted when the example service's interval is invoked. The service * will generate and pass a random number with each invocation. */ export class Interval extends Event < { randomNumber : number } > {} }","title":"Create the event class"},{"location":"getting-started/creating-events/#handle-the-event","text":"Let's go back to the ExampleController class and add a method to handle this event. You can give this method any name, as long as it has the @EventHandler decorator and accepts the event as its sole argument. src/example/ExampleController.ts import { Injectable , Controller , EventHandler } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { @EventHandler public onInterval ( event : ExampleEvent.Interval ) { this . logger . info ( 'Got an invocation with random number:' , event . data . randomNumber ); } }","title":"Handle the event"},{"location":"getting-started/creating-events/#emit-the-event","text":"Now let's go back to the ExampleService class and change the interval's callback to generate a random number and emit the event. src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; import { ExampleEvent } from './ExampleEvent' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . emit ( ExampleEvent . Interval , { randomNumber : Math.floor ( Math . random () * 1000 ) }); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } After saving and running with the new changes, you will immediately see the controller logging a new random number with each passing second.","title":"Emit the event"},{"location":"getting-started/creating-events/#learn-more","text":"Events are emitted globally and can be handled by controllers across the application, including in unrelated modules. This is possible due to the fact that each event class is its own unique signature, thus preventing collisions. You can also emit and listen for events manually using the application's event manager, however using the emit() method inside services is preferred. // Emitting events app . events . emit ( ExampleEvent . Interval , { randomNumber : 0 }); // Listening to events app . events . on ( ExampleEvent . Interval , event => { console . log ( event . data . randomNumber ); }); For more advanced usage details, check out the complete service events guide .","title":"Learn more"},{"location":"getting-started/creating-modules/","text":"Creating modules \u00b6 This framework uses a concept called modules to help organize code. You'll want to bundle related services, controllers, utilities, and other code together inside modules. You can also create nested modules to break down complex logic into smaller parts. You've already created your first module in fact \u2013 the root application class is actually a module, and it can even host its own services and controllers, although this is not recommended as it's best to put those in dedicated modules instead. File structure \u00b6 It's important to have an idea on the file structure you'd like to use. The general convention around here is something like this: src/ \u251c\u2500\u2500 example/ \u2502 \u251c\u2500\u2500 ExampleController.ts \u2502 \u251c\u2500\u2500 ExampleModule.ts \u2502 \u2514\u2500\u2500 ExampleService.ts \u251c\u2500\u2500 advanced/ \u2502 \u251c\u2500\u2500 controllers/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedController1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedController2.ts \u2502 \u251c\u2500\u2500 modules/ \u2502 \u2502 \u251c\u2500\u2500 submodule1/ \u2502 \u2502 \u2514\u2500\u2500 submodule2/ \u2502 \u251c\u2500\u2500 services/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedService1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedService2.ts \u2502 \u2514\u2500\u2500 AdvancedModule.ts \u251c\u2500\u2500 App.ts \u2514\u2500\u2500 main.ts Feel free to use whatever file structure works best for you! Create the module class \u00b6 Create a class called ExampleModule that looks like the following: src/example/ExampleModule.ts import { Module } from '@ts-framework/core' ; import { App } from '../App' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [], controllers : [], }); } } Note the generic in the parent class Module < App > . It's not required, but you should always add a generic pointing to the parent in the hierarchy, all the way up to the root application. This will unlock some extra type hinting that will come in handy later. Import the module \u00b6 With the module's class defined, now we must import it inside a parent module. Let's go back and import it inside the root application module: src/App.ts import { Application } from '@ts-framework/core' ; import { ExampleModule } from './example/ExampleModule' ; export class App extends Application { public constructor () { super ({ imports : [ ExampleModule ], }); } }","title":"Creating modules"},{"location":"getting-started/creating-modules/#creating-modules","text":"This framework uses a concept called modules to help organize code. You'll want to bundle related services, controllers, utilities, and other code together inside modules. You can also create nested modules to break down complex logic into smaller parts. You've already created your first module in fact \u2013 the root application class is actually a module, and it can even host its own services and controllers, although this is not recommended as it's best to put those in dedicated modules instead.","title":"Creating modules"},{"location":"getting-started/creating-modules/#file-structure","text":"It's important to have an idea on the file structure you'd like to use. The general convention around here is something like this: src/ \u251c\u2500\u2500 example/ \u2502 \u251c\u2500\u2500 ExampleController.ts \u2502 \u251c\u2500\u2500 ExampleModule.ts \u2502 \u2514\u2500\u2500 ExampleService.ts \u251c\u2500\u2500 advanced/ \u2502 \u251c\u2500\u2500 controllers/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedController1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedController2.ts \u2502 \u251c\u2500\u2500 modules/ \u2502 \u2502 \u251c\u2500\u2500 submodule1/ \u2502 \u2502 \u2514\u2500\u2500 submodule2/ \u2502 \u251c\u2500\u2500 services/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedService1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedService2.ts \u2502 \u2514\u2500\u2500 AdvancedModule.ts \u251c\u2500\u2500 App.ts \u2514\u2500\u2500 main.ts Feel free to use whatever file structure works best for you!","title":"File structure"},{"location":"getting-started/creating-modules/#create-the-module-class","text":"Create a class called ExampleModule that looks like the following: src/example/ExampleModule.ts import { Module } from '@ts-framework/core' ; import { App } from '../App' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [], controllers : [], }); } } Note the generic in the parent class Module < App > . It's not required, but you should always add a generic pointing to the parent in the hierarchy, all the way up to the root application. This will unlock some extra type hinting that will come in handy later.","title":"Create the module class"},{"location":"getting-started/creating-modules/#import-the-module","text":"With the module's class defined, now we must import it inside a parent module. Let's go back and import it inside the root application module: src/App.ts import { Application } from '@ts-framework/core' ; import { ExampleModule } from './example/ExampleModule' ; export class App extends Application { public constructor () { super ({ imports : [ ExampleModule ], }); } }","title":"Import the module"},{"location":"getting-started/creating-services/","text":"Creating services \u00b6 Services are special classes that host some kind of background activity or process. They can be started and gracefully stopped upon request, and can even extend the functionality of the framework through the attributes system (more on that later). Create the service class \u00b6 Create a class called ExampleService alongside its parent module that looks like the following: src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . logger . info ( 'The interval callback was invoked!' ); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } This simple service starts a one-second interval that prints a message to the output each time. When the service is stopped, the interval is cleared using clearInterval() . Stopping a service safely \u00b6 Note how the stop() method defined above checks if this . interval has been initialized before attempting to clear it. This is an extremely important concept. Imagine this \u2013 the start() method above is called. However, before we have a chance to initialize the interval, an error is thrown by some other code before it. The start has failed. When a service fails to start, the framework will immediately call the stop() method for us to clear anything that was initialized before the error. Import the service \u00b6 Go back to the ExampleModule.ts file and add the new class to the services array. src/example/ExampleModule.ts import { Module } from '@ts-framework/core' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [], }); } }","title":"Creating services"},{"location":"getting-started/creating-services/#creating-services","text":"Services are special classes that host some kind of background activity or process. They can be started and gracefully stopped upon request, and can even extend the functionality of the framework through the attributes system (more on that later).","title":"Creating services"},{"location":"getting-started/creating-services/#create-the-service-class","text":"Create a class called ExampleService alongside its parent module that looks like the following: src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/core' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . logger . info ( 'The interval callback was invoked!' ); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } This simple service starts a one-second interval that prints a message to the output each time. When the service is stopped, the interval is cleared using clearInterval() .","title":"Create the service class"},{"location":"getting-started/creating-services/#stopping-a-service-safely","text":"Note how the stop() method defined above checks if this . interval has been initialized before attempting to clear it. This is an extremely important concept. Imagine this \u2013 the start() method above is called. However, before we have a chance to initialize the interval, an error is thrown by some other code before it. The start has failed. When a service fails to start, the framework will immediately call the stop() method for us to clear anything that was initialized before the error.","title":"Stopping a service safely"},{"location":"getting-started/creating-services/#import-the-service","text":"Go back to the ExampleModule.ts file and add the new class to the services array. src/example/ExampleModule.ts import { Module } from '@ts-framework/core' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [], }); } }","title":"Import the service"},{"location":"getting-started/installation/","text":"Installation \u00b6 Configuration \u00b6 TypeScript \u00b6 Make sure the tsconfig.json file for your project contains the following required settings: { \"compilerOptions\" : { \"emitDecoratorMetadata\" : true , \"experimentalDecorators\" : true } } Browsers \u00b6 The emitDecoratorMetadata property is not supported for ESBuild, which is a common build tool for front-end bundlers and development servers. It is recommended to use swc instead when using this framework in a front-end project. Installation \u00b6 Add the framework into your project as a production dependency. npm install @ts-framework/core It is recommended that the very first import in your project is the @ts-framework/core package, as this will ensure runtime reflection is configured before the rest of your code runs.","title":"Installation"},{"location":"getting-started/installation/#installation","text":"","title":"Installation"},{"location":"getting-started/installation/#configuration","text":"","title":"Configuration"},{"location":"getting-started/installation/#typescript","text":"Make sure the tsconfig.json file for your project contains the following required settings: { \"compilerOptions\" : { \"emitDecoratorMetadata\" : true , \"experimentalDecorators\" : true } }","title":"TypeScript"},{"location":"getting-started/installation/#browsers","text":"The emitDecoratorMetadata property is not supported for ESBuild, which is a common build tool for front-end bundlers and development servers. It is recommended to use swc instead when using this framework in a front-end project.","title":"Browsers"},{"location":"getting-started/installation/#installation_1","text":"Add the framework into your project as a production dependency. npm install @ts-framework/core It is recommended that the very first import in your project is the @ts-framework/core package, as this will ensure runtime reflection is configured before the rest of your code runs.","title":"Installation"},{"location":"integrations/discord/","text":"Discord \u00b6 TODO: How to use the @ts-framework/discord package to build a discord bot, using controllers to handle commands and events.","title":"Discord"},{"location":"integrations/discord/#discord","text":"TODO: How to use the @ts-framework/discord package to build a discord bot, using controllers to handle commands and events.","title":"Discord"},{"location":"integrations/express/","text":"Express \u00b6 TODO: How to use the @ts-framework/express package to build a web application, using controllers to both build and handle routes.","title":"Express"},{"location":"integrations/express/#express","text":"TODO: How to use the @ts-framework/express package to build a web application, using controllers to both build and handle routes.","title":"Express"},{"location":"modules/configuring-modules/","text":"Configuring modules \u00b6 Introduction \u00b6 Modules are bundles of services, controllers, and additional nested child modules which are all related to one another. They allow you to organize and break up your code into different sections, without preventing them from working together. Modules are simple classes. The constructor() must be overridden and the super() constructor must be subsequently invoked to configure the module and its imports. export class ExampleModule extends Module < App > { public constructor () { super ({ // Options go here }); } } Options \u00b6 name? : string \u00b6 The optional name of the module. description? : string \u00b6 The optional description of the module. imports? : Importable [] \u00b6 An array of modules to import into the module. services? : Constructor < Service > [] \u00b6 An array of services to register into the module. controllers? : Constructor < Controller > [] \u00b6 An array of controllers to register into the module. envPrefix? : string \u00b6 The prefix to prepend to all environment variables under the module.","title":"Configuring modules"},{"location":"modules/configuring-modules/#configuring-modules","text":"","title":"Configuring modules"},{"location":"modules/configuring-modules/#introduction","text":"Modules are bundles of services, controllers, and additional nested child modules which are all related to one another. They allow you to organize and break up your code into different sections, without preventing them from working together. Modules are simple classes. The constructor() must be overridden and the super() constructor must be subsequently invoked to configure the module and its imports. export class ExampleModule extends Module < App > { public constructor () { super ({ // Options go here }); } }","title":"Introduction"},{"location":"modules/configuring-modules/#options","text":"","title":"Options"},{"location":"modules/configuring-modules/#property:name","text":"The optional name of the module.","title":"name"},{"location":"modules/configuring-modules/#property:description","text":"The optional description of the module.","title":"description"},{"location":"modules/configuring-modules/#property:imports","text":"An array of modules to import into the module.","title":"imports"},{"location":"modules/configuring-modules/#property:services","text":"An array of services to register into the module.","title":"services"},{"location":"modules/configuring-modules/#property:controllers","text":"An array of controllers to register into the module.","title":"controllers"},{"location":"modules/configuring-modules/#property:envPrefix","text":"The prefix to prepend to all environment variables under the module.","title":"envPrefix"},{"location":"modules/importing-modules/","text":"Importing modules \u00b6 There are various ways to import modules into the application (or underneath other modules). Some of these methods are more advanced than others but unlock additional functionality. Standard imports \u00b6 Importing modules in the most basic form can be done by supplying the module's constructor. The framework will then create instances of that module with default options. { imports : [ ExampleModule ] } Configured imports \u00b6 Passing an object with an import property set to the module constructor will allow you to pass additional options for the module to override its logging level, set custom logging levels, and set its environment prefix. { imports : [ { import : ExampleModule , logging : LogLevel.Information , environment : { EXAMPLE : 'Override the environment' } } ] } All modules also have a static method called withOptions() that can be used as a shortcut for the above code. { imports : [ ExampleModule . withOptions ({ import : ExampleModule , logging : LogLevel.Information , environment : { EXAMPLE : 'Override the environment' } }) ] } Environment imports \u00b6 All modules have a static method called withEnvironment() that can be used to import the module with specific environment variable overrides. { imports : [ ExampleModule . withEnvironment ({ EXAMPLE : 'Override the environment' }) ] } There is also an asynchronous version called withEnvironmentAsync() that can reference environment variables or methods from the current module. { imports : [ ExampleModule . withEnvironmentAsync (() => ({ EXAMPLE : this.env.MESSAGE , ANOTHER : this.environment.get ( 'NAME' ) })) ] } Environment prefix imports \u00b6 All modules have a static method called withEnvironmentPrefix() that can be used to quickly import the module with a custom environment prefix. This prefix will be prepended to all configured environment variables under the module (recursively). { imports : [ ExampleModule . withEnvironmentPrefix ( 'EXAMPLE_' ) ] }","title":"Importing modules"},{"location":"modules/importing-modules/#importing-modules","text":"There are various ways to import modules into the application (or underneath other modules). Some of these methods are more advanced than others but unlock additional functionality.","title":"Importing modules"},{"location":"modules/importing-modules/#standard-imports","text":"Importing modules in the most basic form can be done by supplying the module's constructor. The framework will then create instances of that module with default options. { imports : [ ExampleModule ] }","title":"Standard imports"},{"location":"modules/importing-modules/#configured-imports","text":"Passing an object with an import property set to the module constructor will allow you to pass additional options for the module to override its logging level, set custom logging levels, and set its environment prefix. { imports : [ { import : ExampleModule , logging : LogLevel.Information , environment : { EXAMPLE : 'Override the environment' } } ] } All modules also have a static method called withOptions() that can be used as a shortcut for the above code. { imports : [ ExampleModule . withOptions ({ import : ExampleModule , logging : LogLevel.Information , environment : { EXAMPLE : 'Override the environment' } }) ] }","title":"Configured imports"},{"location":"modules/importing-modules/#environment-imports","text":"All modules have a static method called withEnvironment() that can be used to import the module with specific environment variable overrides. { imports : [ ExampleModule . withEnvironment ({ EXAMPLE : 'Override the environment' }) ] } There is also an asynchronous version called withEnvironmentAsync() that can reference environment variables or methods from the current module. { imports : [ ExampleModule . withEnvironmentAsync (() => ({ EXAMPLE : this.env.MESSAGE , ANOTHER : this.environment.get ( 'NAME' ) })) ] }","title":"Environment imports"},{"location":"modules/importing-modules/#environment-prefix-imports","text":"All modules have a static method called withEnvironmentPrefix() that can be used to quickly import the module with a custom environment prefix. This prefix will be prepended to all configured environment variables under the module (recursively). { imports : [ ExampleModule . withEnvironmentPrefix ( 'EXAMPLE_' ) ] }","title":"Environment prefix imports"},{"location":"modules/lifecycle-methods/","text":"Lifecycle methods \u00b6 Introduction \u00b6 Modules and services have a variety of lifecycle methods which are invoked at different points in the application's execution. You can use these methods to run code at ideal times, and to dynamically set a module's imports. Available methods \u00b6 onModuleRegister () \u00b6 Invoked on modules when they are first registered into the application, immediately before nested modules are resolved. You can use this method to dynamically configure a module's imports if you'd like. beforeModuleBoot () \u00b6 Invoked on modules and services immediately before the first service in the module is started. onModuleBoot () \u00b6 Invoked on modules and services after the last service in the module has finished starting. beforeModuleShutdown () \u00b6 Invoked on modules and services immediately before the first service in the module is stopped. onModuleShutdown () \u00b6 Invoked on modules and services after the last service in the module has finished shutting down.","title":"Lifecycle methods"},{"location":"modules/lifecycle-methods/#lifecycle-methods","text":"","title":"Lifecycle methods"},{"location":"modules/lifecycle-methods/#introduction","text":"Modules and services have a variety of lifecycle methods which are invoked at different points in the application's execution. You can use these methods to run code at ideal times, and to dynamically set a module's imports.","title":"Introduction"},{"location":"modules/lifecycle-methods/#available-methods","text":"","title":"Available methods"},{"location":"modules/lifecycle-methods/#onModuleRegister","text":"Invoked on modules when they are first registered into the application, immediately before nested modules are resolved. You can use this method to dynamically configure a module's imports if you'd like.","title":"onModuleRegister"},{"location":"modules/lifecycle-methods/#beforeModuleBoot","text":"Invoked on modules and services immediately before the first service in the module is started.","title":"beforeModuleBoot"},{"location":"modules/lifecycle-methods/#onModuleBoot","text":"Invoked on modules and services after the last service in the module has finished starting.","title":"onModuleBoot"},{"location":"modules/lifecycle-methods/#beforeModuleShutdown","text":"Invoked on modules and services immediately before the first service in the module is stopped.","title":"beforeModuleShutdown"},{"location":"modules/lifecycle-methods/#onModuleShutdown","text":"Invoked on modules and services after the last service in the module has finished shutting down.","title":"onModuleShutdown"},{"location":"services/adding-attributes/","text":"Adding attributes \u00b6 Attributes are special decorators that your services can use to implement special functionality, create shortcuts, and even create entire new frameworks. Creating attributes \u00b6 The following example shows the implementation of an attribute class and its conversion into a decorator called @Example () . export const Example = Attribute . create ( class extends Attribute { public constructor ( public readonly message? : string ) { super (); } public override onClass ( event : AttributeClassEvent < Component > ) {} public override onMethod ( event : AttributeMethodEvent < Component , any > ) {} public override onProperty ( event : AttributePropertyEvent < Component > ) {} public override onParameter ( event : AttributeParameterEvent < Component > ) {} }); Overrides \u00b6 In the above example, you see four blank methods have been implemented, one for each of classes, methods, properties, and parameters. These methods are special. If you don't override them, the @Example () decorator won't be applicable to those types. Indeed, this means if you only override the onClass() method, the decorator can only be used on classes. This override magic works even if the method is blank, you simply need to override it. The decorator will be guarded against use on non-overridden types both by the TypeScript compiler and at runtime. Decorations \u00b6 The above four methods are invoked at decoration time. If you wish to perform any logic when the decorator is applied, just like you would with a traditional decorator function, you can place that logic in those methods. Using attributes \u00b6 The above attribute supports all four target types, so it can be used across the application in other services and components. @Example ( 'Enter a message here!' ) export class ExampleController extends Controller { @Example () protected async test () { this . logger . info ( 'The test method was invoked.' ); } } Handling attributes \u00b6 The above attribute is useless on its own. You'll also want to handle the attribute inside a corresponding service to implement some associated behavior. protected override register () { const classes = this . application . attributes . getClasses ( this , Example ); const methods = this . application . attributes . getMethods ( this , Example ); for ( const registration of classes ) { } for ( const registration of methods ) { } } The above code will iterate over the registrations for all classes and methods that use the @Example () decorator. There will be one registration per class and per method. These registration objects can be used to obtain information about the attribute and the class instances that use it. You can also obtain each attribute instance, and in the case of method attributes, you can invoke those methods easily using dispatchers. Getting attribute instances \u00b6 The attributes property obtains an array of all attribute instances that were applied to the target class, method, property, or parameter. The decorator can be used multiple times for each, after all. for ( const attribute of registration . attributes ) { this . logger . info ( attribute . message ); } You can also use the first() and last() methods to obtain the first or last attribute instance that was applied to the target. this . logger . info ( registration . first (). message ); Getting target instances \u00b6 This framework allows modules to be imported multiple times, which creates multiple instances of all the services and controllers in them. Perhaps our decorator above was used on a service called ExampleService , but this service is in a module that was imported twice. We can obtain all instances of the target class with the targets property. for ( const target of registration . targets ) { // All targets will be instances of the same class ... // where our decorator was used } Reflecting on targets \u00b6 For advanced use cases, a reflection object is provided with each registration. The type of reflection object will vary depending on the type of target, for example methods will receive a ReflectionMethod instance. this . logger . info ( registration . reflection . name ); this . logger . info ( registration . reflection . getParameters ()); You can use reflection to query other attributes that have been attached on the target classes, methods, properties, and/or parameters. Dispatching methods \u00b6 Method attributes are special in that the underlying methods can be invoked by the service that handles them. A great example of this would be @Get () and @Post () decorators which set up and handle routes on a web server. Method registrations expose a dispatchers property that contains a dispatcher for each instance of the target class. This dispatcher can invoke the method with dependency injection. It inherits from the application's container, and can also be customized. In the following example, we'll invoke methods that use the @Example ( message ) decorator with dependency injection. If the method has a parameter named message , we'll also replace it with the message in the first attribute. for ( const dispatcher of registration . dispatchers ) { dispatcher . setNamedParameter ( 'message' , registration . first (). message ); dispatcher . invoke (); } Dispatchers can set four types of overrides for injection: setNamedParameter ( name : string , value ) setPositionalParameter ( index : number , value ) setTokenParameter ( token : any , value ) setTypedParameter ( type : Type < any > , value ) Use cases \u00b6 You'll always want to implement attributes from a service's register() method, but how you go from there is entirely up to you. You could apply the attributes directly onto an object initialized at construction time, or you could store information about the attributes in properties and apply them when the service starts.","title":"Adding attributes"},{"location":"services/adding-attributes/#adding-attributes","text":"Attributes are special decorators that your services can use to implement special functionality, create shortcuts, and even create entire new frameworks.","title":"Adding attributes"},{"location":"services/adding-attributes/#creating-attributes","text":"The following example shows the implementation of an attribute class and its conversion into a decorator called @Example () . export const Example = Attribute . create ( class extends Attribute { public constructor ( public readonly message? : string ) { super (); } public override onClass ( event : AttributeClassEvent < Component > ) {} public override onMethod ( event : AttributeMethodEvent < Component , any > ) {} public override onProperty ( event : AttributePropertyEvent < Component > ) {} public override onParameter ( event : AttributeParameterEvent < Component > ) {} });","title":"Creating attributes"},{"location":"services/adding-attributes/#overrides","text":"In the above example, you see four blank methods have been implemented, one for each of classes, methods, properties, and parameters. These methods are special. If you don't override them, the @Example () decorator won't be applicable to those types. Indeed, this means if you only override the onClass() method, the decorator can only be used on classes. This override magic works even if the method is blank, you simply need to override it. The decorator will be guarded against use on non-overridden types both by the TypeScript compiler and at runtime.","title":"Overrides"},{"location":"services/adding-attributes/#decorations","text":"The above four methods are invoked at decoration time. If you wish to perform any logic when the decorator is applied, just like you would with a traditional decorator function, you can place that logic in those methods.","title":"Decorations"},{"location":"services/adding-attributes/#using-attributes","text":"The above attribute supports all four target types, so it can be used across the application in other services and components. @Example ( 'Enter a message here!' ) export class ExampleController extends Controller { @Example () protected async test () { this . logger . info ( 'The test method was invoked.' ); } }","title":"Using attributes"},{"location":"services/adding-attributes/#handling-attributes","text":"The above attribute is useless on its own. You'll also want to handle the attribute inside a corresponding service to implement some associated behavior. protected override register () { const classes = this . application . attributes . getClasses ( this , Example ); const methods = this . application . attributes . getMethods ( this , Example ); for ( const registration of classes ) { } for ( const registration of methods ) { } } The above code will iterate over the registrations for all classes and methods that use the @Example () decorator. There will be one registration per class and per method. These registration objects can be used to obtain information about the attribute and the class instances that use it. You can also obtain each attribute instance, and in the case of method attributes, you can invoke those methods easily using dispatchers.","title":"Handling attributes"},{"location":"services/adding-attributes/#getting-attribute-instances","text":"The attributes property obtains an array of all attribute instances that were applied to the target class, method, property, or parameter. The decorator can be used multiple times for each, after all. for ( const attribute of registration . attributes ) { this . logger . info ( attribute . message ); } You can also use the first() and last() methods to obtain the first or last attribute instance that was applied to the target. this . logger . info ( registration . first (). message );","title":"Getting attribute instances"},{"location":"services/adding-attributes/#getting-target-instances","text":"This framework allows modules to be imported multiple times, which creates multiple instances of all the services and controllers in them. Perhaps our decorator above was used on a service called ExampleService , but this service is in a module that was imported twice. We can obtain all instances of the target class with the targets property. for ( const target of registration . targets ) { // All targets will be instances of the same class ... // where our decorator was used }","title":"Getting target instances"},{"location":"services/adding-attributes/#reflecting-on-targets","text":"For advanced use cases, a reflection object is provided with each registration. The type of reflection object will vary depending on the type of target, for example methods will receive a ReflectionMethod instance. this . logger . info ( registration . reflection . name ); this . logger . info ( registration . reflection . getParameters ()); You can use reflection to query other attributes that have been attached on the target classes, methods, properties, and/or parameters.","title":"Reflecting on targets"},{"location":"services/adding-attributes/#dispatching-methods","text":"Method attributes are special in that the underlying methods can be invoked by the service that handles them. A great example of this would be @Get () and @Post () decorators which set up and handle routes on a web server. Method registrations expose a dispatchers property that contains a dispatcher for each instance of the target class. This dispatcher can invoke the method with dependency injection. It inherits from the application's container, and can also be customized. In the following example, we'll invoke methods that use the @Example ( message ) decorator with dependency injection. If the method has a parameter named message , we'll also replace it with the message in the first attribute. for ( const dispatcher of registration . dispatchers ) { dispatcher . setNamedParameter ( 'message' , registration . first (). message ); dispatcher . invoke (); } Dispatchers can set four types of overrides for injection: setNamedParameter ( name : string , value ) setPositionalParameter ( index : number , value ) setTokenParameter ( token : any , value ) setTypedParameter ( type : Type < any > , value )","title":"Dispatching methods"},{"location":"services/adding-attributes/#use-cases","text":"You'll always want to implement attributes from a service's register() method, but how you go from there is entirely up to you. You could apply the attributes directly onto an object initialized at construction time, or you could store information about the attributes in properties and apply them when the service starts.","title":"Use cases"},{"location":"services/adding-events/","text":"Adding events \u00b6 In this framework, controllers can listen for events which are invoked globally by services. Unlike traditional events, which use string keys that can collide, these events use classes which also define the types of data and implement strict typing. Creating events \u00b6 The standard convention for this framework is to create namespaces with event classes inside, thus creating a structure similar to an enum. export namespace ExampleEvent { /** * Invoked when the example service starts, along with a timestamp * for when that happened. */ export class Started extends Event < number > {} /** * Invoked when the example service stops, with no associated data. */ export class Stopped extends Event {} } Sending events \u00b6 You can then send events from within your service using the protected emit() method. protected override async start () { this . emit ( ExampleEvent . Started , Date . now ()); } protected override async stop () { this . emit ( ExampleEvent . Stopped ); } You can also emit events on the application directly, however this is not recommended as the sender property of the event will not be accurate. app . events . emit ( ExampleEvent . Started , Date . now ()); Handling events \u00b6 You can listen for events from both services and controllers by using the @EventHandler decorator along with the event class as the parameter type. @EventHandler protected onExampleStarted ( event : ExampleEvent.Started ) { this . logger . info ( 'Started at:' , event . data ); } Please note that events are global in this framework and these handlers will work regardless of where they are implemented.","title":"Adding events"},{"location":"services/adding-events/#adding-events","text":"In this framework, controllers can listen for events which are invoked globally by services. Unlike traditional events, which use string keys that can collide, these events use classes which also define the types of data and implement strict typing.","title":"Adding events"},{"location":"services/adding-events/#creating-events","text":"The standard convention for this framework is to create namespaces with event classes inside, thus creating a structure similar to an enum. export namespace ExampleEvent { /** * Invoked when the example service starts, along with a timestamp * for when that happened. */ export class Started extends Event < number > {} /** * Invoked when the example service stops, with no associated data. */ export class Stopped extends Event {} }","title":"Creating events"},{"location":"services/adding-events/#sending-events","text":"You can then send events from within your service using the protected emit() method. protected override async start () { this . emit ( ExampleEvent . Started , Date . now ()); } protected override async stop () { this . emit ( ExampleEvent . Stopped ); } You can also emit events on the application directly, however this is not recommended as the sender property of the event will not be accurate. app . events . emit ( ExampleEvent . Started , Date . now ());","title":"Sending events"},{"location":"services/adding-events/#handling-events","text":"You can listen for events from both services and controllers by using the @EventHandler decorator along with the event class as the parameter type. @EventHandler protected onExampleStarted ( event : ExampleEvent.Started ) { this . logger . info ( 'Started at:' , event . data ); } Please note that events are global in this framework and these handlers will work regardless of where they are implemented.","title":"Handling events"},{"location":"services/adding-requests/","text":"Adding requests \u00b6 Requests are similar to events except they can return a response. It's quite similar to remote functions, except they are local. This is useful when running your application alongside another instance or framework. It allows the applications to query information from one another. Creating requests \u00b6 The standard convention for this framework is to create namespaces with request classes inside, thus creating a structure similar to an enum. export namespace ExampleRequest { /** * Adds two or more numbers together and returns the sum. */ export class Add extends Request < number [], number > {} } Sending requests \u00b6 You can then send requests from the application's request manager. const sum = await app . requests . emit ( ExampleRequest . Add , [ 1 , 2 , 3 ]); console . log ( sum ); // 6 Handling requests \u00b6 You can handle requests from both services and controllers by using the @RequestHandler decorator along with the request class as the parameter type. @RequestHandler protected onAdd ( request : ExampleRequest.Add ) { let sum = 0 ; for ( const number of request . data ) { sum += number ; } request . resolve ( sum ); } You must use the resolve() method to respond with a value, and the reject() method to respond with an error. Multiple handlers \u00b6 If a request has multiple handlers available, the first handler that was registered will be invoked, and the others will be ignored. If a handler does not wish to handle a request, it can use the propagate() method to pass it onto the next available handler instead. request . propagate ();","title":"Adding requests"},{"location":"services/adding-requests/#adding-requests","text":"Requests are similar to events except they can return a response. It's quite similar to remote functions, except they are local. This is useful when running your application alongside another instance or framework. It allows the applications to query information from one another.","title":"Adding requests"},{"location":"services/adding-requests/#creating-requests","text":"The standard convention for this framework is to create namespaces with request classes inside, thus creating a structure similar to an enum. export namespace ExampleRequest { /** * Adds two or more numbers together and returns the sum. */ export class Add extends Request < number [], number > {} }","title":"Creating requests"},{"location":"services/adding-requests/#sending-requests","text":"You can then send requests from the application's request manager. const sum = await app . requests . emit ( ExampleRequest . Add , [ 1 , 2 , 3 ]); console . log ( sum ); // 6","title":"Sending requests"},{"location":"services/adding-requests/#handling-requests","text":"You can handle requests from both services and controllers by using the @RequestHandler decorator along with the request class as the parameter type. @RequestHandler protected onAdd ( request : ExampleRequest.Add ) { let sum = 0 ; for ( const number of request . data ) { sum += number ; } request . resolve ( sum ); } You must use the resolve() method to respond with a value, and the reject() method to respond with an error.","title":"Handling requests"},{"location":"services/adding-requests/#multiple-handlers","text":"If a request has multiple handlers available, the first handler that was registered will be invoked, and the others will be ignored. If a handler does not wish to handle a request, it can use the propagate() method to pass it onto the next available handler instead. request . propagate ();","title":"Multiple handlers"},{"location":"services/implementing-services/","text":"Implementing services \u00b6 Services are special classes that host some kind of background activity or process. They can be started and gracefully stopped upon request, and can even extend the functionality of the framework through the attributes system. Implementation \u00b6 @Injectable () export class ExampleService extends Service < ExampleModule > { /** * Invoked immediately before the service is started for the first * time to register attributes and perform any other one-time operations. * This method will not be called again for the duration of the process. */ protected override async register () { } /** * Starts the service. */ protected override async start () { } /** * Stops the service. */ protected override async stop () { } } Dependencies \u00b6 You can utilize dependency injection to obtain instances of other classes, including other services, in the application. When importing other services, the framework will automatically load the service's dependencies first, before it constructs the dependent service. public constructor ( protected readonly other : OtherService ) { super (); } Make sure that you've applied the @Injectable () decorator to the class, otherwise the framework won't be able to see the types of your parameters. Registering services \u00b6 The register() method is invoked once when the service is started for the first time in an application. This makes it the ideal place to implement service attributes and other one-time logic. Starting services \u00b6 The start() method in each service should asynchronously start all tasks that the service will be performing, and should not resolve until they have all been successfully started. You should throw errors from this method if the service is unable to start. In such a case, the framework will invoke the stop() method to stop any tasks that started before the error, and will terminate the startup. Stopping services \u00b6 The stop() method in each service should asynchronously stop all tasks that it was performing, and should not resolve until any outstanding tasks have completed. You should avoid throwing errors from this method. If errors are encountered that may be ignored, use the this . errors . emitPassiveError () method to log it. If an error cannot be ignored, then throw it \u2013 the framework will terminate the process due to an unsafe shutdown. Error handling \u00b6 Services will typically be running tasks in the background while the application is running. Sometimes, they may encounter errors, but due to the asynchronous nature of services, the framework cannot see any errors that are thrown from the background. Instead of throwing errors, use the service's error manager to log it. this . errors . emitPassiveError ( new Error ( 'This error is safe to ignore!' )); this . errors . emitCriticalError ( new Error ( 'Stop the application!' )); The error manager exposes methods to easily listen for promise rejections and error events from event emitters. For all the details, check out the error handling technique guide. By using the error manager instead of throwing, the application and its modules can intercept, transform, and report those errors.","title":"Implementing services"},{"location":"services/implementing-services/#implementing-services","text":"Services are special classes that host some kind of background activity or process. They can be started and gracefully stopped upon request, and can even extend the functionality of the framework through the attributes system.","title":"Implementing services"},{"location":"services/implementing-services/#implementation","text":"@Injectable () export class ExampleService extends Service < ExampleModule > { /** * Invoked immediately before the service is started for the first * time to register attributes and perform any other one-time operations. * This method will not be called again for the duration of the process. */ protected override async register () { } /** * Starts the service. */ protected override async start () { } /** * Stops the service. */ protected override async stop () { } }","title":"Implementation"},{"location":"services/implementing-services/#dependencies","text":"You can utilize dependency injection to obtain instances of other classes, including other services, in the application. When importing other services, the framework will automatically load the service's dependencies first, before it constructs the dependent service. public constructor ( protected readonly other : OtherService ) { super (); } Make sure that you've applied the @Injectable () decorator to the class, otherwise the framework won't be able to see the types of your parameters.","title":"Dependencies"},{"location":"services/implementing-services/#registering-services","text":"The register() method is invoked once when the service is started for the first time in an application. This makes it the ideal place to implement service attributes and other one-time logic.","title":"Registering services"},{"location":"services/implementing-services/#starting-services","text":"The start() method in each service should asynchronously start all tasks that the service will be performing, and should not resolve until they have all been successfully started. You should throw errors from this method if the service is unable to start. In such a case, the framework will invoke the stop() method to stop any tasks that started before the error, and will terminate the startup.","title":"Starting services"},{"location":"services/implementing-services/#stopping-services","text":"The stop() method in each service should asynchronously stop all tasks that it was performing, and should not resolve until any outstanding tasks have completed. You should avoid throwing errors from this method. If errors are encountered that may be ignored, use the this . errors . emitPassiveError () method to log it. If an error cannot be ignored, then throw it \u2013 the framework will terminate the process due to an unsafe shutdown.","title":"Stopping services"},{"location":"services/implementing-services/#error-handling","text":"Services will typically be running tasks in the background while the application is running. Sometimes, they may encounter errors, but due to the asynchronous nature of services, the framework cannot see any errors that are thrown from the background. Instead of throwing errors, use the service's error manager to log it. this . errors . emitPassiveError ( new Error ( 'This error is safe to ignore!' )); this . errors . emitCriticalError ( new Error ( 'Stop the application!' )); The error manager exposes methods to easily listen for promise rejections and error events from event emitters. For all the details, check out the error handling technique guide. By using the error manager instead of throwing, the application and its modules can intercept, transform, and report those errors.","title":"Error handling"},{"location":"services/implementing-state/","text":"Implementing state \u00b6 Introduction \u00b6 As part of their operation, services often keep track of their state using properties on their classes. When services shut down, it is their responsibility to completely clean up and reset all state back to their initial values. However, this can be annoying to implement each time you develop a service. For this reason, the framework exposes a protected object on services called state which helps implement this behavior automatically. In the following example, we create a property called startCounter : number which is incremented each time the service starts. export class ExampleService extends Service < ExampleModule > { protected startCounter = this . state . create ( 0 ); protected async start () { this . startCounter ++ ; } } Without using managed state, this number would indeed increment each time, but with our managed state it can never exceed 1 because it is reset back to the initial value ( 0 ) when the service stops. Methods \u00b6 Creating state \u00b6 Invoke the create < T > () method to create a new managed state property with the given default value. You can pass the type in <T> or infer it from the default value. If a default value is not supplied, undefined will automatically be appended to the possible types. protected num = this . state . create ( 0 ); protected numArray = this . state . create < number [] > ([]); Resetting state \u00b6 Invoke the clear() method to clear all managed state in the parent service and reset them back to their default values. This is done automatically by the framework when the service stops. this . state . clear (); Supported types \u00b6 When the service is restarted, all managed state properties are reverted to new copies of their initial values. This means it needs to be able to create copies of your initial value. At this time, the types of values it can make copies of include: Primitives Arrays Objects Maps Sets Arrow functions Internals \u00b6 It might be important to understand how this functionality works. The create() method actually returns a unique symbol that identifies that individual state property. Then, when the service is registered, the state manager looks over its properties for those symbols, thus associating property names to their values. Once the properties have been identified, they are set to copies of the default values. The clear() method then sets them back to new copies of those default values. For these reasons, the create() method can only be used at construction time. Attempting to create managed state properties at any other point during runtime will raise an error.","title":"Implementing state"},{"location":"services/implementing-state/#implementing-state","text":"","title":"Implementing state"},{"location":"services/implementing-state/#introduction","text":"As part of their operation, services often keep track of their state using properties on their classes. When services shut down, it is their responsibility to completely clean up and reset all state back to their initial values. However, this can be annoying to implement each time you develop a service. For this reason, the framework exposes a protected object on services called state which helps implement this behavior automatically. In the following example, we create a property called startCounter : number which is incremented each time the service starts. export class ExampleService extends Service < ExampleModule > { protected startCounter = this . state . create ( 0 ); protected async start () { this . startCounter ++ ; } } Without using managed state, this number would indeed increment each time, but with our managed state it can never exceed 1 because it is reset back to the initial value ( 0 ) when the service stops.","title":"Introduction"},{"location":"services/implementing-state/#methods","text":"","title":"Methods"},{"location":"services/implementing-state/#creating-state","text":"Invoke the create < T > () method to create a new managed state property with the given default value. You can pass the type in <T> or infer it from the default value. If a default value is not supplied, undefined will automatically be appended to the possible types. protected num = this . state . create ( 0 ); protected numArray = this . state . create < number [] > ([]);","title":"Creating state"},{"location":"services/implementing-state/#resetting-state","text":"Invoke the clear() method to clear all managed state in the parent service and reset them back to their default values. This is done automatically by the framework when the service stops. this . state . clear ();","title":"Resetting state"},{"location":"services/implementing-state/#supported-types","text":"When the service is restarted, all managed state properties are reverted to new copies of their initial values. This means it needs to be able to create copies of your initial value. At this time, the types of values it can make copies of include: Primitives Arrays Objects Maps Sets Arrow functions","title":"Supported types"},{"location":"services/implementing-state/#internals","text":"It might be important to understand how this functionality works. The create() method actually returns a unique symbol that identifies that individual state property. Then, when the service is registered, the state manager looks over its properties for those symbols, thus associating property names to their values. Once the properties have been identified, they are set to copies of the default values. The clear() method then sets them back to new copies of those default values. For these reasons, the create() method can only be used at construction time. Attempting to create managed state properties at any other point during runtime will raise an error.","title":"Internals"},{"location":"services/timeouts-intervals/","text":"Timeouts & intervals \u00b6 Introduction \u00b6 You might be interested in using setTimeout() or setInterval() within your services at some point. If you're not going to be using the dedicated scheduling package then there are some tools available to help you. The main issue with creating timeouts and intervals in a service is that you'll also need to implement logic to clear them from within the stop() method. Instead, use managed timeouts and intervals from the service, as they will clear automatically. Creating timeouts \u00b6 Use the protected scheduler.createTimeout() method on services to create a timeout with the specified interval. protected async start () { const fn = () => this . logger . info ( 'Do something...' ); const timeout = this . scheduler . createTimeout ( fn , 10000 ); } You can also pass a method from the service directly. In this case, the scheduler will invoke the method with this set to the service instance, so you don't need to worry about that. this . schedule . createTimeout ( this . handleTimeout , 10000 ); Creating intervals \u00b6 It's just as simple to create an interval using the schedule.createInterval() method. protected async start () { const fn = () => this . logger . info ( 'Do something...' ); const interval = this . scheduler . createInterval ( fn , 10000 ); } Once again, you can pass a method on the service directly and this will be set to the service instance automatically. this . scheduler . createInterval ( this . handleInterval , 10000 ); Clearing tasks \u00b6 To clear timeouts or intervals from the scheduler, use the clearAll() method on the object that both functions returned. You'll need to use the await operator as this method waits for active callbacks to complete as well. const timeout = this . scheduler . createTimeout (); await timeout . clearAll (); Tip Remember that when using the scheduler, you don't need to clear your timeouts and intervals manually. If there are any scheduled or active tasks when the service is stopped, it will automatically clear them and await their completion. Error handling \u00b6 When errors occur inside a timeout or interval callback, it will be emitted on the service's error manager as a passive error. Please make sure the callback does not return or resolve until it has completed so that the manager may catch any errors which occur. Errors caught from these callbacks will be emitted with the ScheduleError type chained on top of their original errors. See the error handling documentation for full details on how this works.","title":"Timeouts & intervals"},{"location":"services/timeouts-intervals/#timeouts-intervals","text":"","title":"Timeouts &amp; intervals"},{"location":"services/timeouts-intervals/#introduction","text":"You might be interested in using setTimeout() or setInterval() within your services at some point. If you're not going to be using the dedicated scheduling package then there are some tools available to help you. The main issue with creating timeouts and intervals in a service is that you'll also need to implement logic to clear them from within the stop() method. Instead, use managed timeouts and intervals from the service, as they will clear automatically.","title":"Introduction"},{"location":"services/timeouts-intervals/#creating-timeouts","text":"Use the protected scheduler.createTimeout() method on services to create a timeout with the specified interval. protected async start () { const fn = () => this . logger . info ( 'Do something...' ); const timeout = this . scheduler . createTimeout ( fn , 10000 ); } You can also pass a method from the service directly. In this case, the scheduler will invoke the method with this set to the service instance, so you don't need to worry about that. this . schedule . createTimeout ( this . handleTimeout , 10000 );","title":"Creating timeouts"},{"location":"services/timeouts-intervals/#creating-intervals","text":"It's just as simple to create an interval using the schedule.createInterval() method. protected async start () { const fn = () => this . logger . info ( 'Do something...' ); const interval = this . scheduler . createInterval ( fn , 10000 ); } Once again, you can pass a method on the service directly and this will be set to the service instance automatically. this . scheduler . createInterval ( this . handleInterval , 10000 );","title":"Creating intervals"},{"location":"services/timeouts-intervals/#clearing-tasks","text":"To clear timeouts or intervals from the scheduler, use the clearAll() method on the object that both functions returned. You'll need to use the await operator as this method waits for active callbacks to complete as well. const timeout = this . scheduler . createTimeout (); await timeout . clearAll (); Tip Remember that when using the scheduler, you don't need to clear your timeouts and intervals manually. If there are any scheduled or active tasks when the service is stopped, it will automatically clear them and await their completion.","title":"Clearing tasks"},{"location":"services/timeouts-intervals/#error-handling","text":"When errors occur inside a timeout or interval callback, it will be emitted on the service's error manager as a passive error. Please make sure the callback does not return or resolve until it has completed so that the manager may catch any errors which occur. Errors caught from these callbacks will be emitted with the ScheduleError type chained on top of their original errors. See the error handling documentation for full details on how this works.","title":"Error handling"},{"location":"services/tracking-promises/","text":"Tracking promises \u00b6 Introduction \u00b6 Applications frequently perform asynchronous tasks as part of their operation, so they frequently work with promises. When an application is shutting down, it can be easy to leave some promises behind untracked. It's your responsibility to ensure all promises you create are resolved before your service shuts down. The framework makes some tools available to help implement this functionality. Tracking a promise \u00b6 When your service generates a promise in some way, it should pass the promise into the internal promise manager. You can do this while using await on the promise, for example: await this . promises . track ( this . doSomethingAsync ()); Now when the service is asked to shut down, your stop() method will be called like normal, and you will cease the operation of the service as well as the generation of further promises. Once the stop() method has resolved, the framework will wait for the internal promise manager to signal that all tracked promises have resolved. Waiting for promises \u00b6 In some cases, you may wish to wait for all of the tracked promises to complete at a particular moment within your stop() method rather than afterwards. To wait for all tracked promises to complete, use waitAll() . await this . promises . waitAll (); Note that waiting for promises has a default timeout of 60000 milliseconds. You can override this by passing a new duration in the first parameter. await this . promises . waitAll ( 10000 ); When all of the promises finished, true is returned. If one or more promises timed out, false is returned instead.","title":"Tracking promises"},{"location":"services/tracking-promises/#tracking-promises","text":"","title":"Tracking promises"},{"location":"services/tracking-promises/#introduction","text":"Applications frequently perform asynchronous tasks as part of their operation, so they frequently work with promises. When an application is shutting down, it can be easy to leave some promises behind untracked. It's your responsibility to ensure all promises you create are resolved before your service shuts down. The framework makes some tools available to help implement this functionality.","title":"Introduction"},{"location":"services/tracking-promises/#tracking-a-promise","text":"When your service generates a promise in some way, it should pass the promise into the internal promise manager. You can do this while using await on the promise, for example: await this . promises . track ( this . doSomethingAsync ()); Now when the service is asked to shut down, your stop() method will be called like normal, and you will cease the operation of the service as well as the generation of further promises. Once the stop() method has resolved, the framework will wait for the internal promise manager to signal that all tracked promises have resolved.","title":"Tracking a promise"},{"location":"services/tracking-promises/#waiting-for-promises","text":"In some cases, you may wish to wait for all of the tracked promises to complete at a particular moment within your stop() method rather than afterwards. To wait for all tracked promises to complete, use waitAll() . await this . promises . waitAll (); Note that waiting for promises has a default timeout of 60000 milliseconds. You can override this by passing a new duration in the first parameter. await this . promises . waitAll ( 10000 ); When all of the promises finished, true is returned. If one or more promises timed out, false is returned instead.","title":"Waiting for promises"},{"location":"techniques/configuration/","text":"Configuration \u00b6 The framework uses environment variables for its configuration. Each module in the application has an opportunity to define the environment variables it would like to use. These variables are then validated and guaranteed to exist. Adding configuration to a module \u00b6 To declare a module's environment configuration, extend the protected onEnvironment() method. You will receive an instance of EnvironmentManager and are then expected to return the values of your variables using the rules() method on that instance. class ExampleModule extends Module < App > { protected override onEnvironment ( env : EnvironmentManager ) { return env . rules ({ TOKEN : env.schema.string () }); } } With the above example, the application will not start unless the TOKEN is available either in the .env file or as part of the process environment. You can learn more about declaring and validating these variables at @baileyherbert/env . Accessing the configuration \u00b6 You can retrieve values from a module's configuration using its env property if you have a reference to it. The below example shows how to do this from a service, assuming the Service<T> generic is configured properly. public override async start () { const token = this . module .env.TOKEN ; } Note that these environment variables are available globally across the application and multiple modules can use the same names. This also means you can retrieve the value using an environment manager which is commonly exposed as an environment property. public override async start () { const token = this . module .environment.get ( 'TOKEN' ); const token = this . application . environment . get ( 'TOKEN' ); } Setting values on imports \u00b6 It's possible to set or override the values of environment variables for specific modules (and their children) when importing them. export class App extends Application { public constructor () { super ({ imports : [ ExampleModule . withEnvironment ({ TOKEN : 'Sets or overrides the value' }) ] }); } } In these cases, the module's environment and env properties will see the overridden value, but the rest of the application will not. This makes it great for module-specific configuration, and the values can be any type! Note that these custom values remain subject to validation by the imported module or its children via their onEnvironment() methods. Setting values on the application \u00b6 When starting or attaching the application, you have an opportunity to set or override its environment variables without affecting the rest of the application (or other instances of the framework). app . start ({ environment : { TOKEN : 'Sets or overrides the value' } }); Environment prefixes \u00b6 There are certain situations where you might want to apply a prefix to all environment variables within a particular module and its children, or in some cases, the entire application: When multiple application are running in one process When multiple instances of the same module are imported You can pass the envPrefix option when starting the application or when importing a module. All environment variables within the module will then start with that prefix. imports : [ HttpModule . withOptions ({ envPrefix : 'HTTP_' }) ] You can also use the static withEnvironmentPrefix() shortcut method on the module. imports : [ HttpModule . withEnvironmentPrefix ( 'HTTP_' ) ] Now, let's assume the above HttpModule utilizes an environment variable named PORT . It's important to note that this prefix does not apply everywhere. From within your source code, you will continue to refer to it as PORT . For example, the following is valid: imports : [ HttpModule . withOptions ({ envPrefix : 'HTTP_' , env : { PORT : 8080 } }) ] Inside the module and its children, the environment variable will also continue to be exposed with the name PORT , notably lacking the custom prefix we configured. Instead, the prefix applies to the outside sources for our environment variables \u2013 that is our process environment and our .env file. HTTP_PORT=8080 # Correct -- will be used by the module PORT=8080 # Incorrect -- will not be used This is an important concept, allowing you to build your modules to operate independently of others without worrying about environment conflictions, and allowing the user to partition the environment as they desire without affecting your usage of that environment.","title":"Configuration"},{"location":"techniques/configuration/#configuration","text":"The framework uses environment variables for its configuration. Each module in the application has an opportunity to define the environment variables it would like to use. These variables are then validated and guaranteed to exist.","title":"Configuration"},{"location":"techniques/configuration/#adding-configuration-to-a-module","text":"To declare a module's environment configuration, extend the protected onEnvironment() method. You will receive an instance of EnvironmentManager and are then expected to return the values of your variables using the rules() method on that instance. class ExampleModule extends Module < App > { protected override onEnvironment ( env : EnvironmentManager ) { return env . rules ({ TOKEN : env.schema.string () }); } } With the above example, the application will not start unless the TOKEN is available either in the .env file or as part of the process environment. You can learn more about declaring and validating these variables at @baileyherbert/env .","title":"Adding configuration to a module"},{"location":"techniques/configuration/#accessing-the-configuration","text":"You can retrieve values from a module's configuration using its env property if you have a reference to it. The below example shows how to do this from a service, assuming the Service<T> generic is configured properly. public override async start () { const token = this . module .env.TOKEN ; } Note that these environment variables are available globally across the application and multiple modules can use the same names. This also means you can retrieve the value using an environment manager which is commonly exposed as an environment property. public override async start () { const token = this . module .environment.get ( 'TOKEN' ); const token = this . application . environment . get ( 'TOKEN' ); }","title":"Accessing the configuration"},{"location":"techniques/configuration/#setting-values-on-imports","text":"It's possible to set or override the values of environment variables for specific modules (and their children) when importing them. export class App extends Application { public constructor () { super ({ imports : [ ExampleModule . withEnvironment ({ TOKEN : 'Sets or overrides the value' }) ] }); } } In these cases, the module's environment and env properties will see the overridden value, but the rest of the application will not. This makes it great for module-specific configuration, and the values can be any type! Note that these custom values remain subject to validation by the imported module or its children via their onEnvironment() methods.","title":"Setting values on imports"},{"location":"techniques/configuration/#setting-values-on-the-application","text":"When starting or attaching the application, you have an opportunity to set or override its environment variables without affecting the rest of the application (or other instances of the framework). app . start ({ environment : { TOKEN : 'Sets or overrides the value' } });","title":"Setting values on the application"},{"location":"techniques/configuration/#environment-prefixes","text":"There are certain situations where you might want to apply a prefix to all environment variables within a particular module and its children, or in some cases, the entire application: When multiple application are running in one process When multiple instances of the same module are imported You can pass the envPrefix option when starting the application or when importing a module. All environment variables within the module will then start with that prefix. imports : [ HttpModule . withOptions ({ envPrefix : 'HTTP_' }) ] You can also use the static withEnvironmentPrefix() shortcut method on the module. imports : [ HttpModule . withEnvironmentPrefix ( 'HTTP_' ) ] Now, let's assume the above HttpModule utilizes an environment variable named PORT . It's important to note that this prefix does not apply everywhere. From within your source code, you will continue to refer to it as PORT . For example, the following is valid: imports : [ HttpModule . withOptions ({ envPrefix : 'HTTP_' , env : { PORT : 8080 } }) ] Inside the module and its children, the environment variable will also continue to be exposed with the name PORT , notably lacking the custom prefix we configured. Instead, the prefix applies to the outside sources for our environment variables \u2013 that is our process environment and our .env file. HTTP_PORT=8080 # Correct -- will be used by the module PORT=8080 # Incorrect -- will not be used This is an important concept, allowing you to build your modules to operate independently of others without worrying about environment conflictions, and allowing the user to partition the environment as they desire without affecting your usage of that environment.","title":"Environment prefixes"},{"location":"techniques/error-handling/","text":"Error handling \u00b6 Introduction \u00b6 Due to the extensible nature of this framework, it includes tools that make it easier to both throw and handle errors across the application, as well as within individual modules and services. Error managers \u00b6 All major components in the framework \u2013 from the application itself to the individual modules, services, and controllers which power them \u2013 expose a public errors property that has a dedicated error manager assigned specifically to that instance. These managers are standing by to accept any errors that your code needs to report. When an error is reported to a manager, it will be propagated up through its ancestors \u2013 the managers of parent modules \u2013 until it reaches the root manager for the application. It's possible to listen for errors as they pass through specific managers. This makes it easy, for example, to listen for errors across the application (from the root manager) and report them to a remote service such as sentry.io . Error types \u00b6 There are two types of errors that can be sent into managers. Passive errors are errors that indicate a failure has occurred but is safe to ignore or has been recovered from. The application will continue operating normally. Critical errors are errors that indicate a significant failure has occurred and cannot be recovered from. The application will shut down immediately. From a logging perspective, passive errors are emitted under the Error logging level while critical errors are emitted under the Critical logging level. Reporting errors \u00b6 Manual reporting \u00b6 To report a passive error from a service, controller, or module, use the emitPassiveError() method on the nearest available error manager object. this . errors . emitPassiveError ( new Error ( 'Just a scratch!' )); To report a critical error , use the emitCriticalError() method instead. this . errors . emitCriticalError ( new Error ( 'I need a restart!' )); In both cases, you can chain errors by supplying the original error in the second argument of the emit method, preserving the original message and stack as well. catch ( error ) { this . errors . passive ( new Error ( 'Task failed' ), error ); } The full stack for each error in the chain will still be available when handling the error. However, the resulting error will be logged by the framework as the following: Error: Task failed: This is the original error message at <original stack> from Error at <outer stack throw statement> From event emitters \u00b6 In cases where you have an event emitter with an error event, you can easily attach it to the nearest manager and it will listen to this event for you. const emitter = new EventEmitter (); // Attach the emitter (listens to the 'error' event) this . errors . attach ( emitter ); // The manager will emit and propagate the error emitter . emit ( 'error' , new Error ()); These errors will be passive by default, however you can indicate to the manager that they are critical by passing true as the second parameter: this . errors . attach ( emitter , true ); Warning Please note that emitters are never detached from the manager automatically, so you could end up with a memory leak unless you detach them using detach() . From promises \u00b6 You can also use the above attach() method on promises to easily catch any errors they reject with. The manager will listen for those rejections in the background. this . errors . attach ( Promise . reject ()); Detaching objects \u00b6 To detach a promise or emitter from the manager, use the detach() method. this . errors . detach ( emitter ); This is typically not necessary for promises, as they will automatically be detached after they resolve or reject. However, emitters can emit more than one error, so they will never detach on their own and must be managed properly to avoid memory leaks. Handling errors \u00b6 As mentioned in the introduction above, errors propagate up the error manager chain until they reach the root manager. You can use the on() and once() methods to listen for errors as they travel through those managers. When listening for errors, you will receive an ErrorEvent instance containing information about them, as well as a method to stop them from propagating further if you desire. To handle errors, first identify on which error manager you would like to listen. For example, the root application's manager will receive all errors across the entire application, while a module's manager will only receive errors originating from it or its children. Then listen for the passive or critical events to intercept those error types. app . errors . on ( 'passive' , event => { console . error ( 'Intercepted:' , event . error ); console . error ( 'Emitted by:' , event . sender ); }); You can stop the error from propagating further using the stopPropagation() method. event . stopPropagation (); You can also prevent the error from being logged without preventing it from propagating further up the chain using the stopOutput() method. event . stopOutput (); Transforming errors \u00b6 You can transform errors as they pass through managers using the ErrorEvent instances provided in the events demonstrated above. In the following example, we'll use the transform() method to chain errors coming from a specific module such that the topmost error is an InternalServerErrorException instance. httpModule . errors . on ( 'passive' , event => { event . transform ( new InternalServerErrorException ()); }); If you don't silence or stop the error from propagating, it will appear in the application's output under the Error logging level looking something like this: InternalServerErrorException: This is the original error message at <original stack> from Error at <transform call> Creating managers \u00b6 In some circumstances you may wish to create your own managers. You have two options \u2013 you can spawn a child manager from an instance somewhere in the application, or construct a manager manually and then attach it to the application. To spawn a child manager, invoke the createManager() instance and pass a reference to the object you wish to deem the \"sender\" of its errors. Those errors will automatically be propgated up to the parent manager. const manager = app . errors . createManager ( this ); To construct a new manager on your own, pass the same arguments. You may then attach it to a parent manager who will receive your errors using the parent manager's attach() method. const manager = new ErrorManager ( this ); app . errors . attach ( manager );","title":"Error handling"},{"location":"techniques/error-handling/#error-handling","text":"","title":"Error handling"},{"location":"techniques/error-handling/#introduction","text":"Due to the extensible nature of this framework, it includes tools that make it easier to both throw and handle errors across the application, as well as within individual modules and services.","title":"Introduction"},{"location":"techniques/error-handling/#error-managers","text":"All major components in the framework \u2013 from the application itself to the individual modules, services, and controllers which power them \u2013 expose a public errors property that has a dedicated error manager assigned specifically to that instance. These managers are standing by to accept any errors that your code needs to report. When an error is reported to a manager, it will be propagated up through its ancestors \u2013 the managers of parent modules \u2013 until it reaches the root manager for the application. It's possible to listen for errors as they pass through specific managers. This makes it easy, for example, to listen for errors across the application (from the root manager) and report them to a remote service such as sentry.io .","title":"Error managers"},{"location":"techniques/error-handling/#error-types","text":"There are two types of errors that can be sent into managers. Passive errors are errors that indicate a failure has occurred but is safe to ignore or has been recovered from. The application will continue operating normally. Critical errors are errors that indicate a significant failure has occurred and cannot be recovered from. The application will shut down immediately. From a logging perspective, passive errors are emitted under the Error logging level while critical errors are emitted under the Critical logging level.","title":"Error types"},{"location":"techniques/error-handling/#reporting-errors","text":"","title":"Reporting errors"},{"location":"techniques/error-handling/#manual-reporting","text":"To report a passive error from a service, controller, or module, use the emitPassiveError() method on the nearest available error manager object. this . errors . emitPassiveError ( new Error ( 'Just a scratch!' )); To report a critical error , use the emitCriticalError() method instead. this . errors . emitCriticalError ( new Error ( 'I need a restart!' )); In both cases, you can chain errors by supplying the original error in the second argument of the emit method, preserving the original message and stack as well. catch ( error ) { this . errors . passive ( new Error ( 'Task failed' ), error ); } The full stack for each error in the chain will still be available when handling the error. However, the resulting error will be logged by the framework as the following: Error: Task failed: This is the original error message at <original stack> from Error at <outer stack throw statement>","title":"Manual reporting"},{"location":"techniques/error-handling/#from-event-emitters","text":"In cases where you have an event emitter with an error event, you can easily attach it to the nearest manager and it will listen to this event for you. const emitter = new EventEmitter (); // Attach the emitter (listens to the 'error' event) this . errors . attach ( emitter ); // The manager will emit and propagate the error emitter . emit ( 'error' , new Error ()); These errors will be passive by default, however you can indicate to the manager that they are critical by passing true as the second parameter: this . errors . attach ( emitter , true ); Warning Please note that emitters are never detached from the manager automatically, so you could end up with a memory leak unless you detach them using detach() .","title":"From event emitters"},{"location":"techniques/error-handling/#from-promises","text":"You can also use the above attach() method on promises to easily catch any errors they reject with. The manager will listen for those rejections in the background. this . errors . attach ( Promise . reject ());","title":"From promises"},{"location":"techniques/error-handling/#detaching-objects","text":"To detach a promise or emitter from the manager, use the detach() method. this . errors . detach ( emitter ); This is typically not necessary for promises, as they will automatically be detached after they resolve or reject. However, emitters can emit more than one error, so they will never detach on their own and must be managed properly to avoid memory leaks.","title":"Detaching objects"},{"location":"techniques/error-handling/#handling-errors","text":"As mentioned in the introduction above, errors propagate up the error manager chain until they reach the root manager. You can use the on() and once() methods to listen for errors as they travel through those managers. When listening for errors, you will receive an ErrorEvent instance containing information about them, as well as a method to stop them from propagating further if you desire. To handle errors, first identify on which error manager you would like to listen. For example, the root application's manager will receive all errors across the entire application, while a module's manager will only receive errors originating from it or its children. Then listen for the passive or critical events to intercept those error types. app . errors . on ( 'passive' , event => { console . error ( 'Intercepted:' , event . error ); console . error ( 'Emitted by:' , event . sender ); }); You can stop the error from propagating further using the stopPropagation() method. event . stopPropagation (); You can also prevent the error from being logged without preventing it from propagating further up the chain using the stopOutput() method. event . stopOutput ();","title":"Handling errors"},{"location":"techniques/error-handling/#transforming-errors","text":"You can transform errors as they pass through managers using the ErrorEvent instances provided in the events demonstrated above. In the following example, we'll use the transform() method to chain errors coming from a specific module such that the topmost error is an InternalServerErrorException instance. httpModule . errors . on ( 'passive' , event => { event . transform ( new InternalServerErrorException ()); }); If you don't silence or stop the error from propagating, it will appear in the application's output under the Error logging level looking something like this: InternalServerErrorException: This is the original error message at <original stack> from Error at <transform call>","title":"Transforming errors"},{"location":"techniques/error-handling/#creating-managers","text":"In some circumstances you may wish to create your own managers. You have two options \u2013 you can spawn a child manager from an instance somewhere in the application, or construct a manager manually and then attach it to the application. To spawn a child manager, invoke the createManager() instance and pass a reference to the object you wish to deem the \"sender\" of its errors. Those errors will automatically be propgated up to the parent manager. const manager = app . errors . createManager ( this ); To construct a new manager on your own, pass the same arguments. You may then attach it to a parent manager who will receive your errors using the parent manager's attach() method. const manager = new ErrorManager ( this ); app . errors . attach ( manager );","title":"Creating managers"},{"location":"techniques/logging/","text":"Logging \u00b6 This framework has a sweet little logging utility that is easy to access from virtually anywhere, and is highly configurable. Retrieving loggers \u00b6 Each service, controller, and module in the application has a built-in logger that can be accessed with the protected logger property. For example: public override async start () { this . logger . info ( 'Starting the service!' ); } Writing output \u00b6 There are six different logging levels that can be used for output: this . logger . trace ( 'For the most detailed output' ); this . logger . debug ( 'For investigation during development' ); this . logger . info ( 'For tracking the flow of the app' ); this . logger . warning ( 'For abnormal or unexpected events' ); this . logger . error ( 'For failures that cause an activity to stop' ); this . logger . critical ( 'For unrecoverable crashes and failures' ); Logging levels \u00b6 You can adjust the logging level of each module as part of the module's configuration. You can also override this configuration and enforce a logging level when importing a module. From module configuration \u00b6 To set the logging level of a module from its configuration: export class ExampleModule extends Module < App > { public constructor () { super ({ logging : LogLevel.Information , imports : [], }); } } From module imports \u00b6 To enforce a logging level on a module when importing it: super ({ imports : [ ExampleModule . withOptions ({ logging : LogLevel.Information }) ] }) From application start \u00b6 To enforce a logging level on the entire application when attaching it: app . attach ({ loggingLevel : LogLevel.Information }) Logger hierarchy \u00b6 It's important to understand the logger hierarchy when working with logging levels. All of the loggers in your application are connected together in a tree-like structure, with the root application module's logger acting as the entry point. Say you have a deeply nested service like this list: App -> ExampleModule -> NestedModule -> NestedService When the NestedService emits output using its logger, the output will propagate up the chain until it reaches the logger for the root App module. As it travels up this chain, it will be subject to each logger's configured logging level. This means that when the NestedService emits output of the Debug level, it wouldn't arrive to the root logger where it can be printed if any other logger between the two had a higher configured logging level than Debug . Tip This design allows you to limit the amount of output that modules produce, allowing you to build and import noisy and debug-heavy modules without having to limit the rest of your application. For this system to work best, avoid configuring logging levels on your modules unless necessary. If you configure too many modules, it will become difficult to track and modify in the future. Logging to a file \u00b6 With the attach () method \u00b6 When using the attach() method to start the application, you can specify an array of logging transports as part of the attachment options. However, doing so will completely override the default transport (console), so we'll need to add both. app . attach ({ loggingTransports : [ new ConsoleTransport (), new FileTransport ({ fileName : 'console.log' }) ] }); You can customize the minimum logging level individually for each transport as well by passing the logging level as the first parameter, such as: new FileTransport ( LogLevel . Error , { fileName : 'console.log' }) Note that the file transport has built-in automatic rotation that can be configured. Check out the transport documentation for the full details. With the start () method \u00b6 You can use the built-in createFileTransport method on the logger when starting manually. const app = AppFactory . create ( App ); app . logger . createFileTransport ({ fileName : 'console.log' }); app . start (); Learn more \u00b6 Check out the full documentation for the logging library to learn more, such as how to customize the prefixes and how to create your own transports (destinations) for output.","title":"Logging"},{"location":"techniques/logging/#logging","text":"This framework has a sweet little logging utility that is easy to access from virtually anywhere, and is highly configurable.","title":"Logging"},{"location":"techniques/logging/#retrieving-loggers","text":"Each service, controller, and module in the application has a built-in logger that can be accessed with the protected logger property. For example: public override async start () { this . logger . info ( 'Starting the service!' ); }","title":"Retrieving loggers"},{"location":"techniques/logging/#writing-output","text":"There are six different logging levels that can be used for output: this . logger . trace ( 'For the most detailed output' ); this . logger . debug ( 'For investigation during development' ); this . logger . info ( 'For tracking the flow of the app' ); this . logger . warning ( 'For abnormal or unexpected events' ); this . logger . error ( 'For failures that cause an activity to stop' ); this . logger . critical ( 'For unrecoverable crashes and failures' );","title":"Writing output"},{"location":"techniques/logging/#logging-levels","text":"You can adjust the logging level of each module as part of the module's configuration. You can also override this configuration and enforce a logging level when importing a module.","title":"Logging levels"},{"location":"techniques/logging/#from-module-configuration","text":"To set the logging level of a module from its configuration: export class ExampleModule extends Module < App > { public constructor () { super ({ logging : LogLevel.Information , imports : [], }); } }","title":"From module configuration"},{"location":"techniques/logging/#from-module-imports","text":"To enforce a logging level on a module when importing it: super ({ imports : [ ExampleModule . withOptions ({ logging : LogLevel.Information }) ] })","title":"From module imports"},{"location":"techniques/logging/#from-application-start","text":"To enforce a logging level on the entire application when attaching it: app . attach ({ loggingLevel : LogLevel.Information })","title":"From application start"},{"location":"techniques/logging/#logger-hierarchy","text":"It's important to understand the logger hierarchy when working with logging levels. All of the loggers in your application are connected together in a tree-like structure, with the root application module's logger acting as the entry point. Say you have a deeply nested service like this list: App -> ExampleModule -> NestedModule -> NestedService When the NestedService emits output using its logger, the output will propagate up the chain until it reaches the logger for the root App module. As it travels up this chain, it will be subject to each logger's configured logging level. This means that when the NestedService emits output of the Debug level, it wouldn't arrive to the root logger where it can be printed if any other logger between the two had a higher configured logging level than Debug . Tip This design allows you to limit the amount of output that modules produce, allowing you to build and import noisy and debug-heavy modules without having to limit the rest of your application. For this system to work best, avoid configuring logging levels on your modules unless necessary. If you configure too many modules, it will become difficult to track and modify in the future.","title":"Logger hierarchy"},{"location":"techniques/logging/#logging-to-a-file","text":"","title":"Logging to a file"},{"location":"techniques/logging/#with-the-attach-method","text":"When using the attach() method to start the application, you can specify an array of logging transports as part of the attachment options. However, doing so will completely override the default transport (console), so we'll need to add both. app . attach ({ loggingTransports : [ new ConsoleTransport (), new FileTransport ({ fileName : 'console.log' }) ] }); You can customize the minimum logging level individually for each transport as well by passing the logging level as the first parameter, such as: new FileTransport ( LogLevel . Error , { fileName : 'console.log' }) Note that the file transport has built-in automatic rotation that can be configured. Check out the transport documentation for the full details.","title":"With the attach() method"},{"location":"techniques/logging/#with-the-start-method","text":"You can use the built-in createFileTransport method on the logger when starting manually. const app = AppFactory . create ( App ); app . logger . createFileTransport ({ fileName : 'console.log' }); app . start ();","title":"With the start() method"},{"location":"techniques/logging/#learn-more","text":"Check out the full documentation for the logging library to learn more, such as how to customize the prefixes and how to create your own transports (destinations) for output.","title":"Learn more"},{"location":"techniques/queues/","text":"Queues \u00b6 TODO: How to implement queues into an application with the @ts-framework/queue package.","title":"Queues"},{"location":"techniques/queues/#queues","text":"TODO: How to implement queues into an application with the @ts-framework/queue package.","title":"Queues"},{"location":"techniques/scheduling/","text":"Scheduling \u00b6 TODO: How to implement task scheduling into an application with the @ts-framework/scheduler package.","title":"Scheduling"},{"location":"techniques/scheduling/#scheduling","text":"TODO: How to implement task scheduling into an application with the @ts-framework/scheduler package.","title":"Scheduling"},{"location":"techniques/storage/","text":"Storage \u00b6 TODO: How to implement state and file storage into an application with the @ts-framework/storage package.","title":"Storage"},{"location":"techniques/storage/#storage","text":"TODO: How to implement state and file storage into an application with the @ts-framework/storage package.","title":"Storage"}]}