{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 TODO: An introduction to the framework, its purpose and goals, its features, and a quick start guide.","title":"Introduction"},{"location":"#introduction","text":"TODO: An introduction to the framework, its purpose and goals, its features, and a quick start guide.","title":"Introduction"},{"location":"applications/configuring-applications/","text":"Configuring applications \u00b6 TODO: How to configure the root application module and an overview of all available options.","title":"Configuring applications"},{"location":"applications/configuring-applications/#configuring-applications","text":"TODO: How to configure the root application module and an overview of all available options.","title":"Configuring applications"},{"location":"applications/managing-applications/","text":"Managing applications \u00b6 TODO: How to mount applications to the process, start and stop them manually, handle exceptions, etc.","title":"Managing applications"},{"location":"applications/managing-applications/#managing-applications","text":"TODO: How to mount applications to the process, start and stop them manually, handle exceptions, etc.","title":"Managing applications"},{"location":"applications/managing-modules/","text":"Managing modules \u00b6 TODO: How to check the status of and manually start and stop modules using an application's process manager, plus how to track the progress of modules as they work through their lifecycles.","title":"Managing modules"},{"location":"applications/managing-modules/#managing-modules","text":"TODO: How to check the status of and manually start and stop modules using an application's process manager, plus how to track the progress of modules as they work through their lifecycles.","title":"Managing modules"},{"location":"applications/sending-events/","text":"Sending events \u00b6 TODO: How to invoke events into an application, both internally and externally.","title":"Sending events"},{"location":"applications/sending-events/#sending-events","text":"TODO: How to invoke events into an application, both internally and externally.","title":"Sending events"},{"location":"applications/sending-requests/","text":"Sending requests \u00b6 TODO: How to send requests into an application and handle the response, both internally and externally.","title":"Sending requests"},{"location":"applications/sending-requests/#sending-requests","text":"TODO: How to send requests into an application and handle the response, both internally and externally.","title":"Sending requests"},{"location":"controllers/handling-events/","text":"Handling events \u00b6 TODO: How to handle service events from a controller class.","title":"Handling events"},{"location":"controllers/handling-events/#handling-events","text":"TODO: How to handle service events from a controller class.","title":"Handling events"},{"location":"controllers/handling-requests/","text":"Handling requests \u00b6 TODO: How to handle service requests from a controller class.","title":"Handling requests"},{"location":"controllers/handling-requests/#handling-requests","text":"TODO: How to handle service requests from a controller class.","title":"Handling requests"},{"location":"controllers/implementing-controllers/","text":"Implementing controllers \u00b6 TODO: How to implement controller classes and an overview of all available utilities.","title":"Implementing controllers"},{"location":"controllers/implementing-controllers/#implementing-controllers","text":"TODO: How to implement controller classes and an overview of all available utilities.","title":"Implementing controllers"},{"location":"controllers/using-attributes/","text":"Using attributes \u00b6 TODO: How to use attributes to implement functionality in a controller class.","title":"Using attributes"},{"location":"controllers/using-attributes/#using-attributes","text":"TODO: How to use attributes to implement functionality in a controller class.","title":"Using attributes"},{"location":"extensions/developing-extensions/","text":"Developing extensions \u00b6 Extensions allow you to add additional methods and properties to the framework's core classes, and to run code when they are constructed, started, and stopped. The following guide will demonstrate how to successfully add a property and method to services, controllers, and modules. Install the framework \u00b6 You will need to use classes and types from the framework as part of your extension. Add the framework as both a dev and peer dependency in your package.json : \"devDependencies\" : { \"@ts-framework/framework\" : \"^1.0.0\" }, \"peerDependencies\" : { \"@ts-framework/framework\" : \"^1.0.0\" } Then run npm install to download the new packages. Create the extension \u00b6 First create a class that extends FrameworkExtension . This class has some public methods that are invoked by the framework and must be overridden to implement your features. import { FrameworkExtension } from '@ts-framework/framework' ; export class ExampleExtension extends FrameworkExtension { } Add methods and properties \u00b6 Let's start with adding our new property to all instances of the Service class. public override onServiceComposer ( composer : Composer < Service > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); } We'll also add a method to retrieve a similar message. public override onServiceComposer ( composer : Composer < Service > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); composer . createMethod ( 'getExampleMessage' , () => { return 'This was returned by an extension' ; }); } Now let's repeat this for the Controller and Module classes. public override onControllerComposer ( composer : Composer < Controller > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); composer . createMethod ( 'getExampleMessage' , () => { return 'This was returned by an extension' ; }); } public override onModuleComposer ( composer : Composer < Module > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); composer . createMethod ( 'getExampleMessage' , () => { return 'This was returned by an extension' ; }); } Registering the types \u00b6 With the above code, our properties and methods are now applied and can already be used across your application. However, our editors will complain that no such property or method exists as they are not part of the official types. To address this, we'll augment the framework's types by adding the following module declarations below our extension class. declare module '@ts-framework/framework/dist/services/Service' { interface Service { example : string ; getExampleMessage () : string ; } } declare module '@ts-framework/framework/dist/controllers/Controller' { interface Controller { example : string ; getExampleMessage () : string ; } } declare module '@ts-framework/framework/dist/modules/Module' { interface Module { example : string ; getExampleMessage () : string ; } } You can then confirm the types have been added successfully by messing around with the composer.instance property in your extension methods. public override onModuleComposer ( composer : Composer < Module > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); composer . createMethod ( 'getExampleMessage' , () => { return 'This was returned by an extension' ; }); // Your editor should detect this as a (() => string) type composer . instance . getExampleMessage (); } Methods \u00b6 onRegister \u00b6 You can override this method to run code when the extension is registered into the application. This happens quite early, before modules have even been imported. public override onRegister ( application : Application ) {} onApplicationComposer \u00b6 You can override this method to augment the root Application module. public override onApplicationComposer ( composer : Composer < Application > ) {} onModuleComposer \u00b6 You can override this method to augment the Module instances. public override onModuleComposer ( composer : Composer < Module > ) {} onServiceComposer \u00b6 You can override this method to augment the Service instances. public override onServiceComposer ( composer : Composer < Service > ) {} onControllerComposer \u00b6 You can override this method to augment the Controller instances. public override onControllerComposer ( composer : Composer < Controller > ) {} Techniques \u00b6 Logging \u00b6 Extensions have an internal logger as well. When the extension is registered into an application, this logger is automatically attached to the application's root logger. This happens before the extension is invoked in any way. this . logger . info ( 'Hello application!' ); Events \u00b6 Most of the methods listed above receive Composer<T> instances that can be used to augment the target object. However, these instances also have events that you can subscribe to within those methods. public override onServiceComposer ( composer : Composer < Service > ) { composer . on ( 'beforeStart' , () => { this . logger . info ( composer . reflection . name , 'is starting' ); }); } These are the events you can subscribe to: afterResolution \u2013 After the framework has resolved and registered the instance beforeStart \u2013 Immediately before the target is started beforeStop \u2013 Immediately before the target is stopped afterStart \u2013 Immediately after the target was started afterStop \u2013 Immediately after the target was stopped Note that some of these events don't apply to certain objects. For example, the Application class will never trigger the afterResolution event because it was resolved before extensions were loaded. In addition, controllers will never trigger the start/stop events, as they are not stateful.","title":"Developing extensions"},{"location":"extensions/developing-extensions/#developing-extensions","text":"Extensions allow you to add additional methods and properties to the framework's core classes, and to run code when they are constructed, started, and stopped. The following guide will demonstrate how to successfully add a property and method to services, controllers, and modules.","title":"Developing extensions"},{"location":"extensions/developing-extensions/#install-the-framework","text":"You will need to use classes and types from the framework as part of your extension. Add the framework as both a dev and peer dependency in your package.json : \"devDependencies\" : { \"@ts-framework/framework\" : \"^1.0.0\" }, \"peerDependencies\" : { \"@ts-framework/framework\" : \"^1.0.0\" } Then run npm install to download the new packages.","title":"Install the framework"},{"location":"extensions/developing-extensions/#create-the-extension","text":"First create a class that extends FrameworkExtension . This class has some public methods that are invoked by the framework and must be overridden to implement your features. import { FrameworkExtension } from '@ts-framework/framework' ; export class ExampleExtension extends FrameworkExtension { }","title":"Create the extension"},{"location":"extensions/developing-extensions/#add-methods-and-properties","text":"Let's start with adding our new property to all instances of the Service class. public override onServiceComposer ( composer : Composer < Service > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); } We'll also add a method to retrieve a similar message. public override onServiceComposer ( composer : Composer < Service > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); composer . createMethod ( 'getExampleMessage' , () => { return 'This was returned by an extension' ; }); } Now let's repeat this for the Controller and Module classes. public override onControllerComposer ( composer : Composer < Controller > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); composer . createMethod ( 'getExampleMessage' , () => { return 'This was returned by an extension' ; }); } public override onModuleComposer ( composer : Composer < Module > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); composer . createMethod ( 'getExampleMessage' , () => { return 'This was returned by an extension' ; }); }","title":"Add methods and properties"},{"location":"extensions/developing-extensions/#registering-the-types","text":"With the above code, our properties and methods are now applied and can already be used across your application. However, our editors will complain that no such property or method exists as they are not part of the official types. To address this, we'll augment the framework's types by adding the following module declarations below our extension class. declare module '@ts-framework/framework/dist/services/Service' { interface Service { example : string ; getExampleMessage () : string ; } } declare module '@ts-framework/framework/dist/controllers/Controller' { interface Controller { example : string ; getExampleMessage () : string ; } } declare module '@ts-framework/framework/dist/modules/Module' { interface Module { example : string ; getExampleMessage () : string ; } } You can then confirm the types have been added successfully by messing around with the composer.instance property in your extension methods. public override onModuleComposer ( composer : Composer < Module > ) { composer . createProperty ( 'example' , 'This was set from an extension' ); composer . createMethod ( 'getExampleMessage' , () => { return 'This was returned by an extension' ; }); // Your editor should detect this as a (() => string) type composer . instance . getExampleMessage (); }","title":"Registering the types"},{"location":"extensions/developing-extensions/#methods","text":"","title":"Methods"},{"location":"extensions/developing-extensions/#onregister","text":"You can override this method to run code when the extension is registered into the application. This happens quite early, before modules have even been imported. public override onRegister ( application : Application ) {}","title":"onRegister"},{"location":"extensions/developing-extensions/#onapplicationcomposer","text":"You can override this method to augment the root Application module. public override onApplicationComposer ( composer : Composer < Application > ) {}","title":"onApplicationComposer"},{"location":"extensions/developing-extensions/#onmodulecomposer","text":"You can override this method to augment the Module instances. public override onModuleComposer ( composer : Composer < Module > ) {}","title":"onModuleComposer"},{"location":"extensions/developing-extensions/#onservicecomposer","text":"You can override this method to augment the Service instances. public override onServiceComposer ( composer : Composer < Service > ) {}","title":"onServiceComposer"},{"location":"extensions/developing-extensions/#oncontrollercomposer","text":"You can override this method to augment the Controller instances. public override onControllerComposer ( composer : Composer < Controller > ) {}","title":"onControllerComposer"},{"location":"extensions/developing-extensions/#techniques","text":"","title":"Techniques"},{"location":"extensions/developing-extensions/#logging","text":"Extensions have an internal logger as well. When the extension is registered into an application, this logger is automatically attached to the application's root logger. This happens before the extension is invoked in any way. this . logger . info ( 'Hello application!' );","title":"Logging"},{"location":"extensions/developing-extensions/#events","text":"Most of the methods listed above receive Composer<T> instances that can be used to augment the target object. However, these instances also have events that you can subscribe to within those methods. public override onServiceComposer ( composer : Composer < Service > ) { composer . on ( 'beforeStart' , () => { this . logger . info ( composer . reflection . name , 'is starting' ); }); } These are the events you can subscribe to: afterResolution \u2013 After the framework has resolved and registered the instance beforeStart \u2013 Immediately before the target is started beforeStop \u2013 Immediately before the target is stopped afterStart \u2013 Immediately after the target was started afterStop \u2013 Immediately after the target was stopped Note that some of these events don't apply to certain objects. For example, the Application class will never trigger the afterResolution event because it was resolved before extensions were loaded. In addition, controllers will never trigger the start/stop events, as they are not stateful.","title":"Events"},{"location":"extensions/using-extensions/","text":"Using extensions \u00b6 Introduction \u00b6 You can add a lot of functionality to your applications with attributes, but one of the primary goals for this framework is to keep all the essential near developers at all times. We achieve this by exposing them as properties on the Service , Controller , Module , and Application classes, so that your most important and frequently-used tools are one this away at all times. But what if there's something missing? Well, it's very easy to add additional properties and methods to these core classes \u2013 and to run code when they are instantiated, started, and stopped \u2013 using the built-in extensions system. Some of the official framework packages use extensions to implement their features, including: @ts-framework/storage @ts-framework/scheduling @ts-framework/queues Installing extensions \u00b6 First, install the extension into your project as a dependency. npm install @ts-framework/storage Then import the extension into the extensions option for your application. import { StorageExtension } from '@ts-framework/storage' ; export class App extends Application { public constructor () { super ({ extensions : [ new StorageExtension () ] }) } } These extension constructors might accept options to customize their behavior. You'll also need to make sure that the extensions you import are compatible with the framework's current major version, otherwise you might receive an error on the new StorageExtension () line. With the extension imported into the application as shown above, it will take effect immediately, and you can begin using any properties and methods it added to the core classes. Tip If your editor or compiler is telling you that any newly-added properties and methods don't exist, you may need to give it a restart before the new types will be recognized.","title":"Using extensions"},{"location":"extensions/using-extensions/#using-extensions","text":"","title":"Using extensions"},{"location":"extensions/using-extensions/#introduction","text":"You can add a lot of functionality to your applications with attributes, but one of the primary goals for this framework is to keep all the essential near developers at all times. We achieve this by exposing them as properties on the Service , Controller , Module , and Application classes, so that your most important and frequently-used tools are one this away at all times. But what if there's something missing? Well, it's very easy to add additional properties and methods to these core classes \u2013 and to run code when they are instantiated, started, and stopped \u2013 using the built-in extensions system. Some of the official framework packages use extensions to implement their features, including: @ts-framework/storage @ts-framework/scheduling @ts-framework/queues","title":"Introduction"},{"location":"extensions/using-extensions/#installing-extensions","text":"First, install the extension into your project as a dependency. npm install @ts-framework/storage Then import the extension into the extensions option for your application. import { StorageExtension } from '@ts-framework/storage' ; export class App extends Application { public constructor () { super ({ extensions : [ new StorageExtension () ] }) } } These extension constructors might accept options to customize their behavior. You'll also need to make sure that the extensions you import are compatible with the framework's current major version, otherwise you might receive an error on the new StorageExtension () line. With the extension imported into the application as shown above, it will take effect immediately, and you can begin using any properties and methods it added to the core classes. Tip If your editor or compiler is telling you that any newly-added properties and methods don't exist, you may need to give it a restart before the new types will be recognized.","title":"Installing extensions"},{"location":"getting-started/creating-applications/","text":"Creating applications \u00b6 Create the application class \u00b6 Create a class called App to act as the root module of the application. This class will extend the abstract Application class exposed by the framework. You must then invoke the super () constructor to set the application's options. src/App.ts import { Application } from '@ts-framework/framework' ; export class App extends Application { public constructor () { super ({ imports : [], }); } } Starting the application \u00b6 With the root application module defined, let's edit the main entry file of your project such as main.ts and attach the application to the process. src/main.ts import { App } from './App' ; app . attach (); The attach () method is a shortcut that configures the logging level, attaches logging transports, intercepts terminational signals (for a graceful exit), and then starts the application.","title":"Creating applications"},{"location":"getting-started/creating-applications/#creating-applications","text":"","title":"Creating applications"},{"location":"getting-started/creating-applications/#create-the-application-class","text":"Create a class called App to act as the root module of the application. This class will extend the abstract Application class exposed by the framework. You must then invoke the super () constructor to set the application's options. src/App.ts import { Application } from '@ts-framework/framework' ; export class App extends Application { public constructor () { super ({ imports : [], }); } }","title":"Create the application class"},{"location":"getting-started/creating-applications/#starting-the-application","text":"With the root application module defined, let's edit the main entry file of your project such as main.ts and attach the application to the process. src/main.ts import { App } from './App' ; app . attach (); The attach () method is a shortcut that configures the logging level, attaches logging transports, intercepts terminational signals (for a graceful exit), and then starts the application.","title":"Starting the application"},{"location":"getting-started/creating-attributes/","text":"Creating attributes \u00b6 Introduction \u00b6 Here's where the fun really begins! Other frameworks solve particular problems. For example, Nest.js makes it simple to interface with a web server using decorators within controllers. On the other hand, this framework solves no particular problems \u2013 not a single one! Instead, you can build your own solutions to whatever problems you face using service attributes . Need @Get() and @Post() decorators? They can be written in minutes! The framework builds upon the attributes decoration concept introduced in my reflection library . If you're not familiar, attributes are simple classes that are easily converted into decorators, and a class instance is preserved for each decoration. Services have first-class integration with attributes. The framework tracks attribute instances and makes it extremely easy to query and interface with them. This guide will demonstrate how to create the @Get() , @Req() , and @Res() decorators and bind them to a service that spins up an express server. For the record, you don't actually need to do this yourself \u2013 check out the express integration . Create the decorators \u00b6 First and foremost, we'll create the @Get() decorator using an attribute. src/example/attributes/Get.ts import { Attribute , AttributeMethodEvent , Component } from '@ts-framework/framework' ; export const Get = Attribute . create ( class GetAttribute extends Attribute { public constructor ( public readonly path : string ) { super (); } public override onMethod ( event : AttributeMethodEvent < Component , any > ) {} }); Check the upstream documentation on attributes to learn how to easily write your own attributes. In short, by overriding onMethod() in our implementation, we've enabled the attribute to be used on methods, with the constructor argument path as its sole parameter. Create the helper tokens \u00b6 We'll also need the @Req() and @Res() decorators to make it easier to inject the express Request and Response types which don't have an equivalent class readily available for injection. src/example/decorators/Req.ts import { Token } from '@ts-framework/framework' ; export const Req = () => Token ( 'express:request' ); src/example/decorators/Res.ts import { Token } from '@ts-framework/framework' ; export const Res = () => Token ( 'express:response' ); To make this work, we'll need to tell the dependency container what values to inject for these tokens when we invoke the methods that use them. Fortunately, this is very easy to do with the framework's attribute system, as you're about to see. Create the service \u00b6 Create a new HttpService and register it in a module of your choosing. Then read over and implement the code show below. src/example/HttpService.ts import { PromiseCompletionSource , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; import { Get } from './attributes/Get' ; import { Server } from 'http' ; import express from 'express' ; export class HttpService extends Service < ExampleModule > { private app = express (); private server? : Server ; protected override register () { // (1) for ( const registration of this . application . attributes . getMethods ( Get )) { this . app . get ( registration . first (). path , async ( req , res ) => { const dispatcher = registration . dispatchers [ 0 ]. clone (); // (2) dispatcher . setTokenParameter ( 'express:request' , req ); // (3) dispatcher . setTokenParameter ( 'express:response' , res ); const response = await dispatcher . invoke (); // (4) if ( response ) { res . send ( response ); // (5) } }); } } protected override async start () { const source = new PromiseCompletionSource < void > (); this . server = this . app . listen ( 3000 , () => source . resolve ()); // (6) return source . promise ; } protected override async stop () { if ( this . server ) { const source = new PromiseCompletionSource < void > (); this . server . close (() => source . resolve ()); return source . promise ; } } } This is a special method that runs immediately before the service is started for the first time. It won't run again, making it great for slow, one-time operations like applying attributes. The registration object for method-based attributes exposes a dispatcher that can be used to easily invoke the method with dependency injection. We're making a clone to avoid contaminating the original dispatcher object. It's also an array in case there are multiple instances of the same controller available. Here, we're overriding the injection behavior for these specific tokens, which we set with the decorators in the previous section. The container will inject these values for the parameters instead. This will invoke the controller method that registered the route and then forward its return value. We'll await this value just in case it's a promise. If the controller method returned anything, let's add it to the response and send it off. This makes it easier for controllers to send their responses. Here we do some magic to promisify the listen step. We'll repeat similar magic when closing the server. Using the attribute \u00b6 With the attribute and service configured, we can now easily configure and handle routes from any controller in the entire application! src/example/ExampleController.ts export class ExampleController extends Controller < ExampleModule > { @Get ( '/' ) public async index ( @Req () request : Request , @Res () response : Response ) { return 'Hello world!' ; } } Give localhost:3000 a view and you should see the familiar greeting. Conclusion \u00b6 I hope this demonstrates the versatility of this framework. In this manner, it's a framework to create other frameworks, and most of the magic relies on the attribute system. It should be possible to recreate Nest.js in its entirety, or to create an entirely different framework.","title":"Creating attributes"},{"location":"getting-started/creating-attributes/#creating-attributes","text":"","title":"Creating attributes"},{"location":"getting-started/creating-attributes/#introduction","text":"Here's where the fun really begins! Other frameworks solve particular problems. For example, Nest.js makes it simple to interface with a web server using decorators within controllers. On the other hand, this framework solves no particular problems \u2013 not a single one! Instead, you can build your own solutions to whatever problems you face using service attributes . Need @Get() and @Post() decorators? They can be written in minutes! The framework builds upon the attributes decoration concept introduced in my reflection library . If you're not familiar, attributes are simple classes that are easily converted into decorators, and a class instance is preserved for each decoration. Services have first-class integration with attributes. The framework tracks attribute instances and makes it extremely easy to query and interface with them. This guide will demonstrate how to create the @Get() , @Req() , and @Res() decorators and bind them to a service that spins up an express server. For the record, you don't actually need to do this yourself \u2013 check out the express integration .","title":"Introduction"},{"location":"getting-started/creating-attributes/#create-the-decorators","text":"First and foremost, we'll create the @Get() decorator using an attribute. src/example/attributes/Get.ts import { Attribute , AttributeMethodEvent , Component } from '@ts-framework/framework' ; export const Get = Attribute . create ( class GetAttribute extends Attribute { public constructor ( public readonly path : string ) { super (); } public override onMethod ( event : AttributeMethodEvent < Component , any > ) {} }); Check the upstream documentation on attributes to learn how to easily write your own attributes. In short, by overriding onMethod() in our implementation, we've enabled the attribute to be used on methods, with the constructor argument path as its sole parameter.","title":"Create the decorators"},{"location":"getting-started/creating-attributes/#create-the-helper-tokens","text":"We'll also need the @Req() and @Res() decorators to make it easier to inject the express Request and Response types which don't have an equivalent class readily available for injection. src/example/decorators/Req.ts import { Token } from '@ts-framework/framework' ; export const Req = () => Token ( 'express:request' ); src/example/decorators/Res.ts import { Token } from '@ts-framework/framework' ; export const Res = () => Token ( 'express:response' ); To make this work, we'll need to tell the dependency container what values to inject for these tokens when we invoke the methods that use them. Fortunately, this is very easy to do with the framework's attribute system, as you're about to see.","title":"Create the helper tokens"},{"location":"getting-started/creating-attributes/#create-the-service","text":"Create a new HttpService and register it in a module of your choosing. Then read over and implement the code show below. src/example/HttpService.ts import { PromiseCompletionSource , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; import { Get } from './attributes/Get' ; import { Server } from 'http' ; import express from 'express' ; export class HttpService extends Service < ExampleModule > { private app = express (); private server? : Server ; protected override register () { // (1) for ( const registration of this . application . attributes . getMethods ( Get )) { this . app . get ( registration . first (). path , async ( req , res ) => { const dispatcher = registration . dispatchers [ 0 ]. clone (); // (2) dispatcher . setTokenParameter ( 'express:request' , req ); // (3) dispatcher . setTokenParameter ( 'express:response' , res ); const response = await dispatcher . invoke (); // (4) if ( response ) { res . send ( response ); // (5) } }); } } protected override async start () { const source = new PromiseCompletionSource < void > (); this . server = this . app . listen ( 3000 , () => source . resolve ()); // (6) return source . promise ; } protected override async stop () { if ( this . server ) { const source = new PromiseCompletionSource < void > (); this . server . close (() => source . resolve ()); return source . promise ; } } } This is a special method that runs immediately before the service is started for the first time. It won't run again, making it great for slow, one-time operations like applying attributes. The registration object for method-based attributes exposes a dispatcher that can be used to easily invoke the method with dependency injection. We're making a clone to avoid contaminating the original dispatcher object. It's also an array in case there are multiple instances of the same controller available. Here, we're overriding the injection behavior for these specific tokens, which we set with the decorators in the previous section. The container will inject these values for the parameters instead. This will invoke the controller method that registered the route and then forward its return value. We'll await this value just in case it's a promise. If the controller method returned anything, let's add it to the response and send it off. This makes it easier for controllers to send their responses. Here we do some magic to promisify the listen step. We'll repeat similar magic when closing the server.","title":"Create the service"},{"location":"getting-started/creating-attributes/#using-the-attribute","text":"With the attribute and service configured, we can now easily configure and handle routes from any controller in the entire application! src/example/ExampleController.ts export class ExampleController extends Controller < ExampleModule > { @Get ( '/' ) public async index ( @Req () request : Request , @Res () response : Response ) { return 'Hello world!' ; } } Give localhost:3000 a view and you should see the familiar greeting.","title":"Using the attribute"},{"location":"getting-started/creating-attributes/#conclusion","text":"I hope this demonstrates the versatility of this framework. In this manner, it's a framework to create other frameworks, and most of the magic relies on the attribute system. It should be possible to recreate Nest.js in its entirety, or to create an entirely different framework.","title":"Conclusion"},{"location":"getting-started/creating-controllers/","text":"Creating controllers \u00b6 Controllers are classes that handle events dispatched by the application's services. That might sound simple, but events in this framework come in many forms and controllers can easily become the stars of your application. Create the controller class \u00b6 Create a class called ExampleController alongside its parent module that looks like the following: src/example/ExampleController.ts import { Injectable , Controller } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { } For now, there's nothing to put in the controller, so we'll keep it empty. The next guide will modify the service to emit events, and show how to handle those events in the controller. Import the controller \u00b6 Go back to the ExampleModule.ts file and add the new class to the controllers array. src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; import { ExampleController } from './ExampleController' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [ ExampleController ], }); } }","title":"Creating controllers"},{"location":"getting-started/creating-controllers/#creating-controllers","text":"Controllers are classes that handle events dispatched by the application's services. That might sound simple, but events in this framework come in many forms and controllers can easily become the stars of your application.","title":"Creating controllers"},{"location":"getting-started/creating-controllers/#create-the-controller-class","text":"Create a class called ExampleController alongside its parent module that looks like the following: src/example/ExampleController.ts import { Injectable , Controller } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { } For now, there's nothing to put in the controller, so we'll keep it empty. The next guide will modify the service to emit events, and show how to handle those events in the controller.","title":"Create the controller class"},{"location":"getting-started/creating-controllers/#import-the-controller","text":"Go back to the ExampleModule.ts file and add the new class to the controllers array. src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; import { ExampleController } from './ExampleController' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [ ExampleController ], }); } }","title":"Import the controller"},{"location":"getting-started/creating-events/","text":"Creating events \u00b6 This framework introduces a simple concept called service events that makes it extremely easy to listen to and handle events from anywhere in your application. As the name implies, these events typically originate from services as part of their background work. Traditionally, events in the JavaScript ecosystem have used strings as their identifiers. This leads to some difficulty when dealing with collisions and type hinting. Here, we use classes instead of strings for our events, and this solves both of those problems. Create the event namespace \u00b6 The current convention is export a service's events within a namespace. Let's create a simple ExampleEvent namespace within our module's directory. You can skip this step if you'd like. src/example/ExampleEvent.ts export namespace ExampleEvent { } Create the event class \u00b6 Now export a class inside the namespace, making sure to extend the base Event<T> class. If the T decorator is not supplied, the event will not accept any data, otherwise you may specify the type of data it accepts. Let's create an event called ExampleEvent.IntervalInvoked that accepts an object as its data type. Inside this object, we'll pass a random number, because why not? src/example/ExampleEvent.ts import { Event } from '@ts-framework/framework' ; export namespace ExampleEvent { /** * Emitted when the example service's interval is invoked. The service * will generate and pass a random number with each invocation. */ export class Interval extends Event < { randomNumber : number } > {} } Handle the event \u00b6 Let's go back to the ExampleController class and add a method to handle this event. You can give this method any name, as long as it has the @EventHandler decorator and accepts the event as its sole argument. src/example/ExampleController.ts import { Injectable , Controller , EventHandler } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { @EventHandler public onInterval ( event : ExampleEvent.Interval ) { this . logger . info ( 'Got an invocation with random number:' , event . data . randomNumber ); } } Emit the event \u00b6 Now let's go back to the ExampleService class and change the interval's callback to generate a random number and emit the event. src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; import { ExampleEvent } from './ExampleEvent' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . emit ( ExampleEvent . Interval , { randomNumber : Math.floor ( Math . random () * 1000 ) }); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } After saving and running with the new changes, you will immediately see the controller logging a new random number with each passing second. Learn more \u00b6 Events are emitted globally and can be handled by controllers across the application, including in unrelated modules. This is possible due to the fact that each event class is its own unique signature, thus preventing collisions. You can also emit and listen for events manually using the application's event manager, however using the emit() method inside services is preferred. // Emitting events app . events . emit ( ExampleEvent . Interval , { randomNumber : 0 }); // Listening to events app . events . on ( ExampleEvent . Interval , event => { console . log ( event . data . randomNumber ); }); For more advanced usage details, check out the complete service events guide .","title":"Creating events"},{"location":"getting-started/creating-events/#creating-events","text":"This framework introduces a simple concept called service events that makes it extremely easy to listen to and handle events from anywhere in your application. As the name implies, these events typically originate from services as part of their background work. Traditionally, events in the JavaScript ecosystem have used strings as their identifiers. This leads to some difficulty when dealing with collisions and type hinting. Here, we use classes instead of strings for our events, and this solves both of those problems.","title":"Creating events"},{"location":"getting-started/creating-events/#create-the-event-namespace","text":"The current convention is export a service's events within a namespace. Let's create a simple ExampleEvent namespace within our module's directory. You can skip this step if you'd like. src/example/ExampleEvent.ts export namespace ExampleEvent { }","title":"Create the event namespace"},{"location":"getting-started/creating-events/#create-the-event-class","text":"Now export a class inside the namespace, making sure to extend the base Event<T> class. If the T decorator is not supplied, the event will not accept any data, otherwise you may specify the type of data it accepts. Let's create an event called ExampleEvent.IntervalInvoked that accepts an object as its data type. Inside this object, we'll pass a random number, because why not? src/example/ExampleEvent.ts import { Event } from '@ts-framework/framework' ; export namespace ExampleEvent { /** * Emitted when the example service's interval is invoked. The service * will generate and pass a random number with each invocation. */ export class Interval extends Event < { randomNumber : number } > {} }","title":"Create the event class"},{"location":"getting-started/creating-events/#handle-the-event","text":"Let's go back to the ExampleController class and add a method to handle this event. You can give this method any name, as long as it has the @EventHandler decorator and accepts the event as its sole argument. src/example/ExampleController.ts import { Injectable , Controller , EventHandler } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { @EventHandler public onInterval ( event : ExampleEvent.Interval ) { this . logger . info ( 'Got an invocation with random number:' , event . data . randomNumber ); } }","title":"Handle the event"},{"location":"getting-started/creating-events/#emit-the-event","text":"Now let's go back to the ExampleService class and change the interval's callback to generate a random number and emit the event. src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; import { ExampleEvent } from './ExampleEvent' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . emit ( ExampleEvent . Interval , { randomNumber : Math.floor ( Math . random () * 1000 ) }); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } After saving and running with the new changes, you will immediately see the controller logging a new random number with each passing second.","title":"Emit the event"},{"location":"getting-started/creating-events/#learn-more","text":"Events are emitted globally and can be handled by controllers across the application, including in unrelated modules. This is possible due to the fact that each event class is its own unique signature, thus preventing collisions. You can also emit and listen for events manually using the application's event manager, however using the emit() method inside services is preferred. // Emitting events app . events . emit ( ExampleEvent . Interval , { randomNumber : 0 }); // Listening to events app . events . on ( ExampleEvent . Interval , event => { console . log ( event . data . randomNumber ); }); For more advanced usage details, check out the complete service events guide .","title":"Learn more"},{"location":"getting-started/creating-modules/","text":"Creating modules \u00b6 This framework uses a concept called modules to help organize code. You'll want to bundle related services, controllers, utilities, and other code together inside modules. You can also create nested modules to break down complex logic into smaller parts. You've already created your first module in fact \u2013 the root application class is actually a module, and it can even host its own services and controllers, although this is not recommended as it's best to put those in dedicated modules instead. File structure \u00b6 It's important to have an idea on the file structure you'd like to use. The general convention around here is something like this: src/ \u251c\u2500\u2500 example/ \u2502 \u251c\u2500\u2500 ExampleController.ts \u2502 \u251c\u2500\u2500 ExampleModule.ts \u2502 \u2514\u2500\u2500 ExampleService.ts \u251c\u2500\u2500 advanced/ \u2502 \u251c\u2500\u2500 controllers/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedController1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedController2.ts \u2502 \u251c\u2500\u2500 modules/ \u2502 \u2502 \u251c\u2500\u2500 submodule1/ \u2502 \u2502 \u2514\u2500\u2500 submodule2/ \u2502 \u251c\u2500\u2500 services/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedService1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedService2.ts \u2502 \u2514\u2500\u2500 AdvancedModule.ts \u251c\u2500\u2500 App.ts \u2514\u2500\u2500 main.ts Feel free to use whatever file structure works best for you! Create the module class \u00b6 Create a class called ExampleModule that looks like the following: src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [], controllers : [], }); } } Note the generic in the parent class Module < App > . It's not required, but you should always add a generic pointing to the parent in the hierarchy, all the way up to the root application. This will unlock some extra type hinting that will come in handy later. Import the module \u00b6 With the module's class defined, now we must import it inside a parent module. Let's go back and import it inside the root application module: src/App.ts import { Application } from '@ts-framework/framework' ; import { ExampleModule } from './example/ExampleModule' ; export class App extends Application { public constructor () { super ({ imports : [ ExampleModule ], }); } }","title":"Creating modules"},{"location":"getting-started/creating-modules/#creating-modules","text":"This framework uses a concept called modules to help organize code. You'll want to bundle related services, controllers, utilities, and other code together inside modules. You can also create nested modules to break down complex logic into smaller parts. You've already created your first module in fact \u2013 the root application class is actually a module, and it can even host its own services and controllers, although this is not recommended as it's best to put those in dedicated modules instead.","title":"Creating modules"},{"location":"getting-started/creating-modules/#file-structure","text":"It's important to have an idea on the file structure you'd like to use. The general convention around here is something like this: src/ \u251c\u2500\u2500 example/ \u2502 \u251c\u2500\u2500 ExampleController.ts \u2502 \u251c\u2500\u2500 ExampleModule.ts \u2502 \u2514\u2500\u2500 ExampleService.ts \u251c\u2500\u2500 advanced/ \u2502 \u251c\u2500\u2500 controllers/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedController1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedController2.ts \u2502 \u251c\u2500\u2500 modules/ \u2502 \u2502 \u251c\u2500\u2500 submodule1/ \u2502 \u2502 \u2514\u2500\u2500 submodule2/ \u2502 \u251c\u2500\u2500 services/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedService1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedService2.ts \u2502 \u2514\u2500\u2500 AdvancedModule.ts \u251c\u2500\u2500 App.ts \u2514\u2500\u2500 main.ts Feel free to use whatever file structure works best for you!","title":"File structure"},{"location":"getting-started/creating-modules/#create-the-module-class","text":"Create a class called ExampleModule that looks like the following: src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [], controllers : [], }); } } Note the generic in the parent class Module < App > . It's not required, but you should always add a generic pointing to the parent in the hierarchy, all the way up to the root application. This will unlock some extra type hinting that will come in handy later.","title":"Create the module class"},{"location":"getting-started/creating-modules/#import-the-module","text":"With the module's class defined, now we must import it inside a parent module. Let's go back and import it inside the root application module: src/App.ts import { Application } from '@ts-framework/framework' ; import { ExampleModule } from './example/ExampleModule' ; export class App extends Application { public constructor () { super ({ imports : [ ExampleModule ], }); } }","title":"Import the module"},{"location":"getting-started/creating-services/","text":"Creating services \u00b6 Services are special classes that host some kind of background activity or process. They can be started and gracefully stopped upon request, and can even extend the functionality of the framework through the attributes system (more on that later). Create the service class \u00b6 Create a class called ExampleService alongside its parent module that looks like the following: src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . logger . info ( 'The interval callback was invoked!' ); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } This simple service starts a one-second interval that prints a message to the output each time. When the service is stopped, the interval is cleared using clearInterval() . Stopping a service safely \u00b6 Note how the stop() method defined above checks if this . interval has been initialized before attempting to clear it. This is an extremely important concept. Imagine this \u2013 the start() method above is called. However, before we have a chance to initialize the interval, an error is thrown by some other code before it. The start has failed. When a service fails to start, the framework will immediately call the stop() method for us to clear anything that was initialized before the error. Import the service \u00b6 Go back to the ExampleModule.ts file and add the new class to the services array. src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [], }); } }","title":"Creating services"},{"location":"getting-started/creating-services/#creating-services","text":"Services are special classes that host some kind of background activity or process. They can be started and gracefully stopped upon request, and can even extend the functionality of the framework through the attributes system (more on that later).","title":"Creating services"},{"location":"getting-started/creating-services/#create-the-service-class","text":"Create a class called ExampleService alongside its parent module that looks like the following: src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . logger . info ( 'The interval callback was invoked!' ); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } This simple service starts a one-second interval that prints a message to the output each time. When the service is stopped, the interval is cleared using clearInterval() .","title":"Create the service class"},{"location":"getting-started/creating-services/#stopping-a-service-safely","text":"Note how the stop() method defined above checks if this . interval has been initialized before attempting to clear it. This is an extremely important concept. Imagine this \u2013 the start() method above is called. However, before we have a chance to initialize the interval, an error is thrown by some other code before it. The start has failed. When a service fails to start, the framework will immediately call the stop() method for us to clear anything that was initialized before the error.","title":"Stopping a service safely"},{"location":"getting-started/creating-services/#import-the-service","text":"Go back to the ExampleModule.ts file and add the new class to the services array. src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [], }); } }","title":"Import the service"},{"location":"getting-started/installation/","text":"Installation \u00b6 TODO: How to install the framework (standalone, with other frameworks, and into existing projects).","title":"Installation"},{"location":"getting-started/installation/#installation","text":"TODO: How to install the framework (standalone, with other frameworks, and into existing projects).","title":"Installation"},{"location":"integrations/discord/","text":"Discord \u00b6 TODO: How to use the @ts-framework/discord package to build a discord bot, using controllers to handle commands and events.","title":"Discord"},{"location":"integrations/discord/#discord","text":"TODO: How to use the @ts-framework/discord package to build a discord bot, using controllers to handle commands and events.","title":"Discord"},{"location":"integrations/express/","text":"Express \u00b6 TODO: How to use the @ts-framework/express package to build a web application, using controllers to both build and handle routes.","title":"Express"},{"location":"integrations/express/#express","text":"TODO: How to use the @ts-framework/express package to build a web application, using controllers to both build and handle routes.","title":"Express"},{"location":"modules/configuring-modules/","text":"Configuring modules \u00b6 TODO: How to configure modules and an overview of all available options.","title":"Configuring modules"},{"location":"modules/configuring-modules/#configuring-modules","text":"TODO: How to configure modules and an overview of all available options.","title":"Configuring modules"},{"location":"modules/importing-modules/","text":"Importing modules \u00b6 TODO: How to import modules from a third party package.","title":"Importing modules"},{"location":"modules/importing-modules/#importing-modules","text":"TODO: How to import modules from a third party package.","title":"Importing modules"},{"location":"modules/lifecycle-methods/","text":"Lifecycle methods \u00b6 TODO: How to implement lifecycle methods into modules and an overview of all available methods.","title":"Lifecycle methods"},{"location":"modules/lifecycle-methods/#lifecycle-methods","text":"TODO: How to implement lifecycle methods into modules and an overview of all available methods.","title":"Lifecycle methods"},{"location":"modules/publishing-modules/","text":"Publishing modules \u00b6 TODO: How to publish a module to a package manager (npm) for third party consumption.","title":"Publishing modules"},{"location":"modules/publishing-modules/#publishing-modules","text":"TODO: How to publish a module to a package manager (npm) for third party consumption.","title":"Publishing modules"},{"location":"services/adding-attributes/","text":"Adding attributes \u00b6 TODO: How to create and implement service attributes.","title":"Adding attributes"},{"location":"services/adding-attributes/#adding-attributes","text":"TODO: How to create and implement service attributes.","title":"Adding attributes"},{"location":"services/adding-events/","text":"Adding events \u00b6 TODO: How to create and invoke service events.","title":"Adding events"},{"location":"services/adding-events/#adding-events","text":"TODO: How to create and invoke service events.","title":"Adding events"},{"location":"services/adding-requests/","text":"Adding requests \u00b6 TODO: How to create and invoke service requests.","title":"Adding requests"},{"location":"services/adding-requests/#adding-requests","text":"TODO: How to create and invoke service requests.","title":"Adding requests"},{"location":"services/implementing-services/","text":"Implementing services \u00b6 TODO: How to implement service classes and an overview of all available methods and utilities.","title":"Implementing services"},{"location":"services/implementing-services/#implementing-services","text":"TODO: How to implement service classes and an overview of all available methods and utilities.","title":"Implementing services"},{"location":"services/implementing-state/","text":"Implementing state \u00b6 Introduction \u00b6 As part of their operation, services often keep track of their state using properties on their classes. When services shut down, it is their responsibility to completely clean up and reset all state back to their initial values. However, this can be annoying to implement each time you develop a service. For this reason, the framework exposes a protected object on services called state which helps implement this behavior automatically. In the following example, we create a property called startCounter : number which is incremented each time the service starts. export class ExampleService extends Service < ExampleModule > { protected startCounter = this . state . create ( 0 ); protected async start () { this . startCounter ++ ; } } Without using managed state, this number would indeed increment each time, but with our managed state it can never exceed 1 because it is reset back to the initial value ( 0 ) when the service stops. Methods \u00b6 Creating state \u00b6 Invoke the create < T > () method to create a new managed state property with the given default value. You can pass the type in <T> or infer it from the default value. If a default value is not supplied, undefined will automatically be appended to the possible types. protected num = this . state . create ( 0 ); protected numArray = this . state . create < number [] > ([]); Resetting state \u00b6 Invoke the clear() method to clear all managed state in the parent service and reset them back to their default values. This is done automatically by the framework when the service stops. this . state . clear (); Supported types \u00b6 When the service is restarted, all managed state properties are reverted to new copies of their initial values. This means it needs to be able to create copies of your initial value. At this time, the types of values it can make copies of include: Primitives Arrays Objects Maps Sets Arrow functions Internals \u00b6 It might be important to understand how this functionality works. The create() method actually returns a unique symbol that identifies that individual state property. Then, when the service is registered, the state manager looks over its properties for those symbols, thus associating property names to their values. Once the properties have been identified, they are set to copies of the default values. The clear() method then sets them back to new copies of those default values. For these reasons, the create() method can only be used at construction time. Attempting to create managed state properties at any other point during runtime will raise an error.","title":"Implementing state"},{"location":"services/implementing-state/#implementing-state","text":"","title":"Implementing state"},{"location":"services/implementing-state/#introduction","text":"As part of their operation, services often keep track of their state using properties on their classes. When services shut down, it is their responsibility to completely clean up and reset all state back to their initial values. However, this can be annoying to implement each time you develop a service. For this reason, the framework exposes a protected object on services called state which helps implement this behavior automatically. In the following example, we create a property called startCounter : number which is incremented each time the service starts. export class ExampleService extends Service < ExampleModule > { protected startCounter = this . state . create ( 0 ); protected async start () { this . startCounter ++ ; } } Without using managed state, this number would indeed increment each time, but with our managed state it can never exceed 1 because it is reset back to the initial value ( 0 ) when the service stops.","title":"Introduction"},{"location":"services/implementing-state/#methods","text":"","title":"Methods"},{"location":"services/implementing-state/#creating-state","text":"Invoke the create < T > () method to create a new managed state property with the given default value. You can pass the type in <T> or infer it from the default value. If a default value is not supplied, undefined will automatically be appended to the possible types. protected num = this . state . create ( 0 ); protected numArray = this . state . create < number [] > ([]);","title":"Creating state"},{"location":"services/implementing-state/#resetting-state","text":"Invoke the clear() method to clear all managed state in the parent service and reset them back to their default values. This is done automatically by the framework when the service stops. this . state . clear ();","title":"Resetting state"},{"location":"services/implementing-state/#supported-types","text":"When the service is restarted, all managed state properties are reverted to new copies of their initial values. This means it needs to be able to create copies of your initial value. At this time, the types of values it can make copies of include: Primitives Arrays Objects Maps Sets Arrow functions","title":"Supported types"},{"location":"services/implementing-state/#internals","text":"It might be important to understand how this functionality works. The create() method actually returns a unique symbol that identifies that individual state property. Then, when the service is registered, the state manager looks over its properties for those symbols, thus associating property names to their values. Once the properties have been identified, they are set to copies of the default values. The clear() method then sets them back to new copies of those default values. For these reasons, the create() method can only be used at construction time. Attempting to create managed state properties at any other point during runtime will raise an error.","title":"Internals"},{"location":"services/timeouts-intervals/","text":"Timeouts & intervals \u00b6 Introduction \u00b6 You might be interested in using setTimeout() or setInterval() within your services at some point. If you're not going to be using the dedicated scheduling package then there are some tools available to help you. The main issue with creating timeouts and intervals in a service is that you'll also need to implement logic to clear them from within the stop() method. Instead, use managed timeouts and intervals from the service, as they will clear automatically. Creating timeouts \u00b6 Use the protected scheduler.createTimeout() method on services to create a timeout with the specified interval. protected async start () { const fn = () => this . logger . info ( 'Do something...' ); const timeout = this . scheduler . createTimeout ( fn , 10000 ); } You can also pass a method from the service directly. In this case, the scheduler will invoke the method with this set to the service instance, so you don't need to worry about that. this . schedule . createTimeout ( this . handleTimeout , 10000 ); Creating intervals \u00b6 It's just as simple to create an interval using the schedule.createInterval() method. protected async start () { const fn = () => this . logger . info ( 'Do something...' ); const interval = this . scheduler . createInterval ( fn , 10000 ); } Once again, you can pass a method on the service directly and this will be set to the service instance automatically. this . scheduler . createInterval ( this . handleInterval , 10000 ); Clearing tasks \u00b6 To clear timeouts or intervals from the scheduler, use the clearAll() method on the object that both functions returned. You'll need to use the await operator as this method waits for active callbacks to complete as well. const timeout = this . scheduler . createTimeout (); await timeout . clearAll (); Tip Remember that when using the scheduler, you don't need to clear your timeouts and intervals manually. If there are any scheduled or active tasks when the service is stopped, it will automatically clear them and await their completion. Error handling \u00b6 When errors occur inside a timeout or interval callback, it will be emitted on the service's error manager as a passive error. Please make sure the callback does not return or resolve until it has completed so that the manager may catch any errors which occur. Errors caught from these callbacks will be emitted with the ScheduleError type chained on top of their original errors. See the error handling documentation for full details on how this works.","title":"Timeouts & intervals"},{"location":"services/timeouts-intervals/#timeouts-intervals","text":"","title":"Timeouts &amp; intervals"},{"location":"services/timeouts-intervals/#introduction","text":"You might be interested in using setTimeout() or setInterval() within your services at some point. If you're not going to be using the dedicated scheduling package then there are some tools available to help you. The main issue with creating timeouts and intervals in a service is that you'll also need to implement logic to clear them from within the stop() method. Instead, use managed timeouts and intervals from the service, as they will clear automatically.","title":"Introduction"},{"location":"services/timeouts-intervals/#creating-timeouts","text":"Use the protected scheduler.createTimeout() method on services to create a timeout with the specified interval. protected async start () { const fn = () => this . logger . info ( 'Do something...' ); const timeout = this . scheduler . createTimeout ( fn , 10000 ); } You can also pass a method from the service directly. In this case, the scheduler will invoke the method with this set to the service instance, so you don't need to worry about that. this . schedule . createTimeout ( this . handleTimeout , 10000 );","title":"Creating timeouts"},{"location":"services/timeouts-intervals/#creating-intervals","text":"It's just as simple to create an interval using the schedule.createInterval() method. protected async start () { const fn = () => this . logger . info ( 'Do something...' ); const interval = this . scheduler . createInterval ( fn , 10000 ); } Once again, you can pass a method on the service directly and this will be set to the service instance automatically. this . scheduler . createInterval ( this . handleInterval , 10000 );","title":"Creating intervals"},{"location":"services/timeouts-intervals/#clearing-tasks","text":"To clear timeouts or intervals from the scheduler, use the clearAll() method on the object that both functions returned. You'll need to use the await operator as this method waits for active callbacks to complete as well. const timeout = this . scheduler . createTimeout (); await timeout . clearAll (); Tip Remember that when using the scheduler, you don't need to clear your timeouts and intervals manually. If there are any scheduled or active tasks when the service is stopped, it will automatically clear them and await their completion.","title":"Clearing tasks"},{"location":"services/timeouts-intervals/#error-handling","text":"When errors occur inside a timeout or interval callback, it will be emitted on the service's error manager as a passive error. Please make sure the callback does not return or resolve until it has completed so that the manager may catch any errors which occur. Errors caught from these callbacks will be emitted with the ScheduleError type chained on top of their original errors. See the error handling documentation for full details on how this works.","title":"Error handling"},{"location":"services/tracking-promises/","text":"Tracking promises \u00b6 Introduction \u00b6 Applications frequently perform asynchronous tasks as part of their operation, so they frequently work wiht promises. When an application is shutting down, it can be easy to leave some promises behind untracked. It's your responsibility to ensure all promises you create are resolved before your service shuts down. The framework makes some tools available to help implement this functionality. Tracking a promise \u00b6 When your service generates a promise in some way, it should pass the promise into the internal promise manager. You can do this while using await on the promise, for example: await this . promises . track ( this . doSomethingAsync ()); Now when the service is asked to shut down, your stop() method will be called like normal, and you will cease the operation of the service as well as the generation of further promises. Once the stop() method has resolved, the framework will wait for the internal promise manager to signal that all tracked promises have resolved. Waiting for promises \u00b6 In some cases, you may wish to wait for all of the tracked promises to complete at a particular moment within your stop() method rather than afterwards. To wait for all tracked promises to complete, use waitAll() . await this . promises . waitAll (); Note that waiting for promises has a default timeout of 60000 milliseconds. You can override this by passing a new duration in the first parameter. await this . promises . waitAll ( 10000 ); When all of the promises finished, true is returned. If one or more promises timed out, false is returned instead.","title":"Tracking promises"},{"location":"services/tracking-promises/#tracking-promises","text":"","title":"Tracking promises"},{"location":"services/tracking-promises/#introduction","text":"Applications frequently perform asynchronous tasks as part of their operation, so they frequently work wiht promises. When an application is shutting down, it can be easy to leave some promises behind untracked. It's your responsibility to ensure all promises you create are resolved before your service shuts down. The framework makes some tools available to help implement this functionality.","title":"Introduction"},{"location":"services/tracking-promises/#tracking-a-promise","text":"When your service generates a promise in some way, it should pass the promise into the internal promise manager. You can do this while using await on the promise, for example: await this . promises . track ( this . doSomethingAsync ()); Now when the service is asked to shut down, your stop() method will be called like normal, and you will cease the operation of the service as well as the generation of further promises. Once the stop() method has resolved, the framework will wait for the internal promise manager to signal that all tracked promises have resolved.","title":"Tracking a promise"},{"location":"services/tracking-promises/#waiting-for-promises","text":"In some cases, you may wish to wait for all of the tracked promises to complete at a particular moment within your stop() method rather than afterwards. To wait for all tracked promises to complete, use waitAll() . await this . promises . waitAll (); Note that waiting for promises has a default timeout of 60000 milliseconds. You can override this by passing a new duration in the first parameter. await this . promises . waitAll ( 10000 ); When all of the promises finished, true is returned. If one or more promises timed out, false is returned instead.","title":"Waiting for promises"},{"location":"techniques/configuration/","text":"Configuration \u00b6 The framework uses environment variables for its configuration. Each module in the application has an opportunity to define the environment variables it would like to use. These variables are then validated and guaranteed to exist. Adding configuration to a module \u00b6 To declare a module's environment configuration, extend the protected onEnvironment() method. You will receive an instance of EnvironmentManager and are then expected to return the values of your variables using the rules() method on that instance. class ExampleModule extends Module < App > { protected override onEnvironment ( env : EnvironmentManager ) { return env . rules ({ TOKEN : env.schema.string () }); } } With the above example, the application will not start unless the TOKEN is available either in the .env file or as part of the process environment. You can learn more about declaring and validating these variables at @baileyherbert/env . Accessing the configuration \u00b6 You can retrieve values from a module's configuration using its env property if you have a reference to it. The below example shows how to do this from a service, assuming the Service<T> generic is configured properly. public override async start () { const token = this . module .env.TOKEN ; } Note that these environment variables are available globally across the application and multiple modules can use the same names. This also means you can retrieve the value using an environment manager which is commonly exposed as an environment property. public override async start () { const token = this . module .environment.get ( 'TOKEN' ); const token = this . application . environment . get ( 'TOKEN' ); } Setting values on imports \u00b6 It's possible to set or override the values of environment variables for specific modules (and their children) when importing them. export class App extends Application { public constructor () { super ({ imports : [ ExampleModule . withEnvironment ({ TOKEN : 'Sets or overrides the value' }) ] }); } } In these cases, the module's environment and env properties will see the overridden value, but the rest of the application will not. This makes it great for module-specific configuration, and the values can be any type! Note that these custom values remain subject to validation by the imported module or its children via their onEnvironment() methods. Setting values on the application \u00b6 When starting or attaching the application, you have an opportunity to set or override its environment variables without affecting the rest of the application (or other instances of the framework). app . start ({ environment : { TOKEN : 'Sets or overrides the value' } });","title":"Configuration"},{"location":"techniques/configuration/#configuration","text":"The framework uses environment variables for its configuration. Each module in the application has an opportunity to define the environment variables it would like to use. These variables are then validated and guaranteed to exist.","title":"Configuration"},{"location":"techniques/configuration/#adding-configuration-to-a-module","text":"To declare a module's environment configuration, extend the protected onEnvironment() method. You will receive an instance of EnvironmentManager and are then expected to return the values of your variables using the rules() method on that instance. class ExampleModule extends Module < App > { protected override onEnvironment ( env : EnvironmentManager ) { return env . rules ({ TOKEN : env.schema.string () }); } } With the above example, the application will not start unless the TOKEN is available either in the .env file or as part of the process environment. You can learn more about declaring and validating these variables at @baileyherbert/env .","title":"Adding configuration to a module"},{"location":"techniques/configuration/#accessing-the-configuration","text":"You can retrieve values from a module's configuration using its env property if you have a reference to it. The below example shows how to do this from a service, assuming the Service<T> generic is configured properly. public override async start () { const token = this . module .env.TOKEN ; } Note that these environment variables are available globally across the application and multiple modules can use the same names. This also means you can retrieve the value using an environment manager which is commonly exposed as an environment property. public override async start () { const token = this . module .environment.get ( 'TOKEN' ); const token = this . application . environment . get ( 'TOKEN' ); }","title":"Accessing the configuration"},{"location":"techniques/configuration/#setting-values-on-imports","text":"It's possible to set or override the values of environment variables for specific modules (and their children) when importing them. export class App extends Application { public constructor () { super ({ imports : [ ExampleModule . withEnvironment ({ TOKEN : 'Sets or overrides the value' }) ] }); } } In these cases, the module's environment and env properties will see the overridden value, but the rest of the application will not. This makes it great for module-specific configuration, and the values can be any type! Note that these custom values remain subject to validation by the imported module or its children via their onEnvironment() methods.","title":"Setting values on imports"},{"location":"techniques/configuration/#setting-values-on-the-application","text":"When starting or attaching the application, you have an opportunity to set or override its environment variables without affecting the rest of the application (or other instances of the framework). app . start ({ environment : { TOKEN : 'Sets or overrides the value' } });","title":"Setting values on the application"},{"location":"techniques/error-handling/","text":"Error handling \u00b6 Introduction \u00b6 Due to the extensible nature of this framework, it includes tools that make it easier to both throw and handle errors across the application, as well as within individual modules and services. Error managers \u00b6 All major components in the framework \u2013 from the application itself to the individual modules, services, and controllers which power them \u2013 expose a public errors property that has a dedicated error manager assigned specifically to that instance. These managers are standing by to accept any errors that your code needs to report. When an error is reported to a manager, it will be propagated up through its ancestors \u2013 the managers of parent modules \u2013 until it reaches the root manager for the application. It's possible to listen for errors as they pass through specific managers. This makes it easy, for example, to listen for errors across the application (from the root manager) and report them to a remote service such as sentry.io . Error types \u00b6 There are two types of errors that can be sent into managers. Passive errors are errors that indicate a failure has occurred but is safe to ignore or has been recovered from. The application will continue operating normally. Critical errors are errors that indicate a significant failure has occurred and cannot be recovered from. The application will shut down immediately. From a logging perspective, passive errors are emitted under the Error logging level while critical errors are emitted under the Critical logging level. Reporting errors \u00b6 Manual reporting \u00b6 To report a passive error from a service, controller, or module, use the emitPassiveError() method on the nearest available error manager object. this . errors . emitPassiveError ( new Error ( 'Just a scratch!' )); To report a critical error , use the emitCriticalError() method instead. this . errors . emitCriticalError ( new Error ( 'I need a restart!' )); In both cases, you can chain errors by supplying the original error in the second argument of the emit method, preserving the original message and stack as well. catch ( error ) { this . errors . passive ( new Error ( 'Task failed' ), error ); } The full stack for each error in the chain will still be available when handling the error. However, the resulting error will be logged by the framework as the following: Error: Task failed: This is the original error message at <original stack> from Error at <outer stack throw statement> From event emitters \u00b6 In cases where you have an event emitter with an error event, you can easily attach it to the nearest manager and it will listen to this event for you. const emitter = new EventEmitter (); // Attach the emitter (listens to the 'error' event) this . errors . attach ( emitter ); // The manager will emit and propagate the error emitter . emit ( 'error' , new Error ()); These errors will be passive by default, however you can indicate to the manager that they are critical by passing true as the second parameter: this . errors . attach ( emitter , true ); Warning Please note that emitters are never detached from the manager automatically, so you could end up with a memory leak unless you detach them using detach() . From promises \u00b6 You can also use the above attach() method on promises to easily catch any errors they reject with. The manager will listen for those rejections in the background. this . errors . attach ( Promise . reject ()); Detaching objects \u00b6 To detach a promise or emitter from the manager, use the detach() method. this . errors . detach ( emitter ); This is typically not necessary for promises, as they will automatically be detached after they resolve or reject. However, emitters can emit more than one error, so they will never detach on their own and must be managed properly to avoid memory leaks. Handling errors \u00b6 As mentioned in the introduction above, errors propagate up the error manager chain until they reach the root manager. You can use the on() and once() methods to listen for errors as they travel through those managers. When listening for errors, you will receive an ErrorEvent instance containing information about them, as well as a method to stop them from propagating further if you desire. To handle errors, first identify on which error manager you would like to listen. For example, the root application's manager will receive all errors across the entire application, while a module's manager will only receive errors originating from it or its children. Then listen for the passive or critical events to intercept those error types. app . errors . on ( 'passive' , event => { console . error ( 'Intercepted:' , event . error ); console . error ( 'Emitted by:' , event . sender ); }); You can stop the error from propagating further using the stopPropagation() method. event . stopPropagation (); You can also prevent the error from being logged without preventing it from propagating further up the chain using the stopOutput() method. event . stopOutput (); Transforming errors \u00b6 You can transform errors as they pass through managers using the ErrorEvent instances provided in the events demonstrated above. In the following example, we'll use the transform() method to chain errors coming from a specific module such that the topmost error is an InternalServerErrorException instance. httpModule . errors . on ( 'passive' , event => { event . transform ( new InternalServerErrorException ()); }); If you don't silence or stop the error from propagating, it will appear in the application's output under the Error logging level looking something like this: InternalServerErrorException: This is the original error message at <original stack> from Error at <transform call> Creating managers \u00b6 In some circumstances you may wish to create your own managers. You have two options \u2013 you can spawn a child manager from an instance somewhere in the application, or construct a manager manually and then attach it to the application. To spawn a child manager, invoke the createManager() instance and pass a reference to the object you wish to deem the \"sender\" of its errors. Those errors will automatically be propgated up to the parent manager. const manager = app . errors . createManager ( this ); To construct a new manager on your own, pass the same arguments. You may then attach it to a parent manager who will receive your errors using the parent manager's attach() method. const manager = new ErrorManager ( this ); app . errors . attach ( manager );","title":"Error handling"},{"location":"techniques/error-handling/#error-handling","text":"","title":"Error handling"},{"location":"techniques/error-handling/#introduction","text":"Due to the extensible nature of this framework, it includes tools that make it easier to both throw and handle errors across the application, as well as within individual modules and services.","title":"Introduction"},{"location":"techniques/error-handling/#error-managers","text":"All major components in the framework \u2013 from the application itself to the individual modules, services, and controllers which power them \u2013 expose a public errors property that has a dedicated error manager assigned specifically to that instance. These managers are standing by to accept any errors that your code needs to report. When an error is reported to a manager, it will be propagated up through its ancestors \u2013 the managers of parent modules \u2013 until it reaches the root manager for the application. It's possible to listen for errors as they pass through specific managers. This makes it easy, for example, to listen for errors across the application (from the root manager) and report them to a remote service such as sentry.io .","title":"Error managers"},{"location":"techniques/error-handling/#error-types","text":"There are two types of errors that can be sent into managers. Passive errors are errors that indicate a failure has occurred but is safe to ignore or has been recovered from. The application will continue operating normally. Critical errors are errors that indicate a significant failure has occurred and cannot be recovered from. The application will shut down immediately. From a logging perspective, passive errors are emitted under the Error logging level while critical errors are emitted under the Critical logging level.","title":"Error types"},{"location":"techniques/error-handling/#reporting-errors","text":"","title":"Reporting errors"},{"location":"techniques/error-handling/#manual-reporting","text":"To report a passive error from a service, controller, or module, use the emitPassiveError() method on the nearest available error manager object. this . errors . emitPassiveError ( new Error ( 'Just a scratch!' )); To report a critical error , use the emitCriticalError() method instead. this . errors . emitCriticalError ( new Error ( 'I need a restart!' )); In both cases, you can chain errors by supplying the original error in the second argument of the emit method, preserving the original message and stack as well. catch ( error ) { this . errors . passive ( new Error ( 'Task failed' ), error ); } The full stack for each error in the chain will still be available when handling the error. However, the resulting error will be logged by the framework as the following: Error: Task failed: This is the original error message at <original stack> from Error at <outer stack throw statement>","title":"Manual reporting"},{"location":"techniques/error-handling/#from-event-emitters","text":"In cases where you have an event emitter with an error event, you can easily attach it to the nearest manager and it will listen to this event for you. const emitter = new EventEmitter (); // Attach the emitter (listens to the 'error' event) this . errors . attach ( emitter ); // The manager will emit and propagate the error emitter . emit ( 'error' , new Error ()); These errors will be passive by default, however you can indicate to the manager that they are critical by passing true as the second parameter: this . errors . attach ( emitter , true ); Warning Please note that emitters are never detached from the manager automatically, so you could end up with a memory leak unless you detach them using detach() .","title":"From event emitters"},{"location":"techniques/error-handling/#from-promises","text":"You can also use the above attach() method on promises to easily catch any errors they reject with. The manager will listen for those rejections in the background. this . errors . attach ( Promise . reject ());","title":"From promises"},{"location":"techniques/error-handling/#detaching-objects","text":"To detach a promise or emitter from the manager, use the detach() method. this . errors . detach ( emitter ); This is typically not necessary for promises, as they will automatically be detached after they resolve or reject. However, emitters can emit more than one error, so they will never detach on their own and must be managed properly to avoid memory leaks.","title":"Detaching objects"},{"location":"techniques/error-handling/#handling-errors","text":"As mentioned in the introduction above, errors propagate up the error manager chain until they reach the root manager. You can use the on() and once() methods to listen for errors as they travel through those managers. When listening for errors, you will receive an ErrorEvent instance containing information about them, as well as a method to stop them from propagating further if you desire. To handle errors, first identify on which error manager you would like to listen. For example, the root application's manager will receive all errors across the entire application, while a module's manager will only receive errors originating from it or its children. Then listen for the passive or critical events to intercept those error types. app . errors . on ( 'passive' , event => { console . error ( 'Intercepted:' , event . error ); console . error ( 'Emitted by:' , event . sender ); }); You can stop the error from propagating further using the stopPropagation() method. event . stopPropagation (); You can also prevent the error from being logged without preventing it from propagating further up the chain using the stopOutput() method. event . stopOutput ();","title":"Handling errors"},{"location":"techniques/error-handling/#transforming-errors","text":"You can transform errors as they pass through managers using the ErrorEvent instances provided in the events demonstrated above. In the following example, we'll use the transform() method to chain errors coming from a specific module such that the topmost error is an InternalServerErrorException instance. httpModule . errors . on ( 'passive' , event => { event . transform ( new InternalServerErrorException ()); }); If you don't silence or stop the error from propagating, it will appear in the application's output under the Error logging level looking something like this: InternalServerErrorException: This is the original error message at <original stack> from Error at <transform call>","title":"Transforming errors"},{"location":"techniques/error-handling/#creating-managers","text":"In some circumstances you may wish to create your own managers. You have two options \u2013 you can spawn a child manager from an instance somewhere in the application, or construct a manager manually and then attach it to the application. To spawn a child manager, invoke the createManager() instance and pass a reference to the object you wish to deem the \"sender\" of its errors. Those errors will automatically be propgated up to the parent manager. const manager = app . errors . createManager ( this ); To construct a new manager on your own, pass the same arguments. You may then attach it to a parent manager who will receive your errors using the parent manager's attach() method. const manager = new ErrorManager ( this ); app . errors . attach ( manager );","title":"Creating managers"},{"location":"techniques/logging/","text":"Logging \u00b6 This framework has a sweet little logging utility that is easy to access from virtually anywhere, and is highly configurable. Retrieving loggers \u00b6 Each service, controller, and module in the application has a built-in logger that can be accessed with the protected logger property. For example: public override async start () { this . logger . info ( 'Starting the service!' ); } Writing output \u00b6 There are six different logging levels that can be used for output: this . logger . trace ( 'For the most detailed output' ); this . logger . debug ( 'For investigation during development' ); this . logger . info ( 'For tracking the flow of the app' ); this . logger . warning ( 'For abnormal or unexpected events' ); this . logger . error ( 'For failures that cause an activity to stop' ); this . logger . critical ( 'For unrecoverable crashes and failures' ); Logging levels \u00b6 You can adjust the logging level of each module as part of the module's configuration. You can also override this configuration and enforce a logging level when importing a module. From module configuration \u00b6 To set the logging level of a module from its configuration: export class ExampleModule extends Module < App > { public constructor () { super ({ logging : LogLevel.Information , imports : [], }); } } From module imports \u00b6 To enforce a logging level on a module when importing it: super ({ imports : [ ExampleModule . withOptions ({ logging : LogLevel.Information }) ] }) From application start \u00b6 To enforce a logging level on the entire application when attaching it: app . attach ({ loggingLevel : LogLevel.Information }) Logger hierarchy \u00b6 It's important to understand the logger hierarchy when working with logging levels. All of the loggers in your application are connected together in a tree-like structure, with the root application module's logger acting as the entry point. Say you have a deeply nested service like this list: App -> ExampleModule -> NestedModule -> NestedService When the NestedService emits output using its logger, the output will propagate up the chain until it reaches the logger for the root App module. As it travels up this chain, it will be subject to each logger's configured logging level. This means that when the NestedService emits output of the Debug level, it wouldn't arrive to the root logger where it can be printed if any other logger between the two had a higher configured logging level than Debug . Tip This design allows you to limit the amount of output that modules produce, allowing you to build and import noisy and debug-heavy modules without having to limit the rest of your application. For this system to work best, avoid configuring logging levels on your modules unless necessary. If you configure too many modules, it will become difficult to track and modify in the future. Logging to a file \u00b6 With the attach () method \u00b6 When using the attach() method to start the application, you can specify an array of logging transports as part of the attachment options. However, doing so will completely override the default transport (console), so we'll need to add both. app . attach ({ loggingTransports : [ new ConsoleTransport (), new FileTransport ({ fileName : 'console.log' }) ] }); You can customize the minimum logging level individually for each transport as well by passing the logging level as the first parameter, such as: new FileTransport ( LogLevel . Error , { fileName : 'console.log' }) Note that the file transport has built-in automatic rotation that can be configured. Check out the transport documentation for the full details. With the start () method \u00b6 You can use the built-in createFileTransport method on the logger when starting manually. const app = AppFactory . create ( App ); app . logger . createFileTransport ({ fileName : 'console.log' }); app . start (); Learn more \u00b6 Check out the full documentation for the logging library to learn more, such as how to customize the prefixes and how to create your own transports (destinations) for output.","title":"Logging"},{"location":"techniques/logging/#logging","text":"This framework has a sweet little logging utility that is easy to access from virtually anywhere, and is highly configurable.","title":"Logging"},{"location":"techniques/logging/#retrieving-loggers","text":"Each service, controller, and module in the application has a built-in logger that can be accessed with the protected logger property. For example: public override async start () { this . logger . info ( 'Starting the service!' ); }","title":"Retrieving loggers"},{"location":"techniques/logging/#writing-output","text":"There are six different logging levels that can be used for output: this . logger . trace ( 'For the most detailed output' ); this . logger . debug ( 'For investigation during development' ); this . logger . info ( 'For tracking the flow of the app' ); this . logger . warning ( 'For abnormal or unexpected events' ); this . logger . error ( 'For failures that cause an activity to stop' ); this . logger . critical ( 'For unrecoverable crashes and failures' );","title":"Writing output"},{"location":"techniques/logging/#logging-levels","text":"You can adjust the logging level of each module as part of the module's configuration. You can also override this configuration and enforce a logging level when importing a module.","title":"Logging levels"},{"location":"techniques/logging/#from-module-configuration","text":"To set the logging level of a module from its configuration: export class ExampleModule extends Module < App > { public constructor () { super ({ logging : LogLevel.Information , imports : [], }); } }","title":"From module configuration"},{"location":"techniques/logging/#from-module-imports","text":"To enforce a logging level on a module when importing it: super ({ imports : [ ExampleModule . withOptions ({ logging : LogLevel.Information }) ] })","title":"From module imports"},{"location":"techniques/logging/#from-application-start","text":"To enforce a logging level on the entire application when attaching it: app . attach ({ loggingLevel : LogLevel.Information })","title":"From application start"},{"location":"techniques/logging/#logger-hierarchy","text":"It's important to understand the logger hierarchy when working with logging levels. All of the loggers in your application are connected together in a tree-like structure, with the root application module's logger acting as the entry point. Say you have a deeply nested service like this list: App -> ExampleModule -> NestedModule -> NestedService When the NestedService emits output using its logger, the output will propagate up the chain until it reaches the logger for the root App module. As it travels up this chain, it will be subject to each logger's configured logging level. This means that when the NestedService emits output of the Debug level, it wouldn't arrive to the root logger where it can be printed if any other logger between the two had a higher configured logging level than Debug . Tip This design allows you to limit the amount of output that modules produce, allowing you to build and import noisy and debug-heavy modules without having to limit the rest of your application. For this system to work best, avoid configuring logging levels on your modules unless necessary. If you configure too many modules, it will become difficult to track and modify in the future.","title":"Logger hierarchy"},{"location":"techniques/logging/#logging-to-a-file","text":"","title":"Logging to a file"},{"location":"techniques/logging/#with-the-attach-method","text":"When using the attach() method to start the application, you can specify an array of logging transports as part of the attachment options. However, doing so will completely override the default transport (console), so we'll need to add both. app . attach ({ loggingTransports : [ new ConsoleTransport (), new FileTransport ({ fileName : 'console.log' }) ] }); You can customize the minimum logging level individually for each transport as well by passing the logging level as the first parameter, such as: new FileTransport ( LogLevel . Error , { fileName : 'console.log' }) Note that the file transport has built-in automatic rotation that can be configured. Check out the transport documentation for the full details.","title":"With the attach() method"},{"location":"techniques/logging/#with-the-start-method","text":"You can use the built-in createFileTransport method on the logger when starting manually. const app = AppFactory . create ( App ); app . logger . createFileTransport ({ fileName : 'console.log' }); app . start ();","title":"With the start() method"},{"location":"techniques/logging/#learn-more","text":"Check out the full documentation for the logging library to learn more, such as how to customize the prefixes and how to create your own transports (destinations) for output.","title":"Learn more"},{"location":"techniques/queues/","text":"Queues \u00b6 TODO: How to implement queues into an application with the @ts-framework/queue package.","title":"Queues"},{"location":"techniques/queues/#queues","text":"TODO: How to implement queues into an application with the @ts-framework/queue package.","title":"Queues"},{"location":"techniques/scheduling/","text":"Scheduling \u00b6 TODO: How to implement task scheduling into an application with the @ts-framework/scheduler package.","title":"Scheduling"},{"location":"techniques/scheduling/#scheduling","text":"TODO: How to implement task scheduling into an application with the @ts-framework/scheduler package.","title":"Scheduling"},{"location":"techniques/storage/","text":"Storage \u00b6 TODO: How to implement state and file storage into an application with the @ts-framework/storage package.","title":"Storage"},{"location":"techniques/storage/#storage","text":"TODO: How to implement state and file storage into an application with the @ts-framework/storage package.","title":"Storage"}]}